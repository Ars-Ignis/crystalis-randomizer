Maps are stored in the 64K chunk from $00000 to $0ffff, along with a few strings
Format:
 - each map is a 16x16 block, many have solid ff's on the entire $0xxf0 row.
 - $01f00 is the left-hand exit to Swan.


leaf: 66a2
north of leaf: 1ed8, north of that: 1d67

nes.debug.patchRom(0x1da3, 0x80) -> has visible effect on terrain

Each byte in a map is a 16x16 pixel block (so each map covers 256x256, a single screen)
Windmill cave entrance is $9e00..$9eff
 - later 84, 8b, 81
 --> this is the first block of data in the MapData table
     - first byte is the music
     - second next looks like some sort of dimensions?
 - read by $3e639




$35a85 seems to read from this PRG rom.

  $35f02: d0 02    BNE $35f06  
  $35f04: a9 40    LDA #$40    
  $35f06: 20 30 9a JSR $9a30     write $01f9 <- $9f  write $01f8 <- $8
  $35a30: 85 14    STA $14       write $0014 <- $40
  $35a32: 10 19    BPL $35a4d  
  $35a4d: a5 37    LDA $37       read $0037 -> $6
  $35a4f: 0a       ASL         
  $35a50: 0a       ASL         
  $35a51: 0a       ASL         
  $35a52: 05 35    ORA $35       read $0035 -> $3
  $35a54: a8       TAY         
  $35a55: b9 00 63 LDA $6300,y   read $6333 -> $1e
  $35a58: 29 1f    AND #$1f    
  $35a5a: 09 a0    ORA #$a0    
  $35a5c: 85 11    STA $11       write $0011 <- $be
  $35a5e: b9 00 63 LDA $6300,y   read $6333 -> $1e
  $35a61: 2a       ROL         
  $35a62: 2a       ROL         
  $35a63: 2a       ROL         
  $35a64: 2a       ROL         
  $35a65: 29 07    AND #$07    
  $35a67: 85 6f    STA $6f       write $006f <- $0
  $35a69: a0 07    LDY #$07    
  $35a6b: 84 50    STY $50       write $0050 <- $7
  $35a6d: 8c 00 80 STY $8000     write $8000 <- $7
  $35a70: 8d 01 80 STA $8001     write $8001 <- $0
  $35a73: a5 36    LDA $36       read $0036 -> $df
  $35a75: 29 f0    AND #$f0    
  $35a77: 85 12    STA $12       write $0012 <- $d0
  $35a79: a5 34    LDA $34       read $0034 -> $80
  $35a7b: 4a       LSR         
  $35a7c: 4a       LSR         
  $35a7d: 4a       LSR         
  $35a7e: 4a       LSR         
  $35a7f: 05 12    ORA $12       read $0012 -> $d0
  $35a81: 85 10    STA $10       write $0010 <- $d8
  $35a83: a0 00    LDY #$00    
  $35a85: b1 10    LDA ($10),y   read $0010 -> $bed8  read $01ed8 -> $f7
  $35a87: 85 68    STA $68       write $0068 <- $f7

Implicates $37, $35, $34 as being interesting?

   ($37 << 3) | $35 gives index into $6300 table
     -> note: this is cartridge ram...
   zero high 3 bits, add 8&2 bits to high => $11 which is MSB of address
   $10 comes from ($34 >> 4) | $12


=====

Wind
$00,$00,$2b,$00,$00
$00,$2c,$2a,$00,$00
$0c,$16,$16,$0d,$00
$15,$29,$24,$04,$00
$01,$27,$23,$0b,$0d
$0e,$07,$37,$1d,$03
$00,$00,$0e,$1e,$0f

Cordel-West
$00,$00,$00,$2a,$00,$0c,$16,$0d
$00,$0c,$11,$16,$0d,$0e,$33,$0f
$0c,$34,$14,$17,$18,$0c,$16,$0d
$15,$06,$20,$21,$30,$26,$32,$10
$1c,$05,$2e,$09,$22,$37,$32,$04
$0e,$37,$2f,$03,$00,$0e,$07,$0f
$0c,$34,$2e,$35,$0d,$00,$00,$00
$1a,$07,$22,$33,$0f,$00,$00,$00

Waterfall               Lime Tree
$3e,$00,$0c,$31,$0d     $0c,$16,$0d
$13,$11,$26,$2f,$19     $0e,$37,$10
$12,$17,$21,$28,$03     $ff,$0e,$0f
$0e,$07,$33,$22,$0f
$00,$00,$2a,$00,$00
$00,$0c,$16,$0d,$00
$0c,$26,$14,$18,$00
$01,$32,$2f,$10,$0a
$1a,$07,$22,$0f,$00

A lot of similar screens - must be making good use of color maps
 - can change the 0e to 1a and add an extra exit to lime tree -> amazones
 - also need to change the ff to 00 for good measure, though it doesn't
   match too well..
   - but we also need a river block because otherwise can reach amazones from
     the portoa side before sword of water
     - a8 looks like the tile we want...? but will need to make it 4x3 probably?
     not valid with these tiles - instead need waterfall...?
     - 31-2f-22 works (tho the extra cave is unfortunate)
     - will need to figur out how to make the ice block work, since it's
       not enabled just from the tiles, it appears

 - will need to find space for 8 more bytes?
 - find some map data that's unused???

We could get back some bytes by reprogramming how this data table is read.
In particular, MapData[0] could be encoded in 2 bytes rather than 4, which
would recover 512 bytes for larger maps if we wanted it.
 - width and height seem to max out at $0b, so we could pack them into one byte;
 - [0][2] is only 0, 1, 2, or 3; and [0][3] is only 0 or $80
   - so these could also be packed into a single byte with room to spare.
 - what do they mean?!? 62fc..62ff
 - would need to use some of the recovered space for a slightly longer parsing
   routine to jump to, but that wouldn't require all the space.
