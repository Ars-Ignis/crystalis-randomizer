#!/usr/bin/env node -r esm
import './build_info.js';
import { EXPECTED_CRC32 } from './rom.js';
import { FlagSet, Preset } from './flagset.js';
import { crc32 } from './crc32.js';
import * as fs from 'fs';
import * as patch from './patch.js';
import { UsageError, breakLines } from './util.js';
import { NodeReader } from './nodereader.js';
import * as version from './version.js';
import { disableAsserts } from './assert.js';
const usage = (code) => {
    console.log(`Crystalis Randomizer v${version.VERSION}
Usage: cryr [OPTIONS...] rom.nes

Options
  --flags=FLAGSET    Specify the flagset.
  --preset=PRESET    Specify the preset by name.
                     Spaces and capitalization are ignored.
  --seed=SEED        Specify the seed.
  --output=PATTERN   Specify the output filename pattern.
                     May include placeholders:
                       %n: input base filename
                       %v: cryr version hash
                       %s: seed
                       %f: flagset
                       %c: checksum
                     The default pattern is "%n_%c".
  --count=NUMBER     Number of shuffled roms to generate.
                     This flag is not compatible with specifying
                     a seed manually, nor with output patterns
                     that don't include %s or %c.
  --force            Don't fail due to wrong input file checksum.

Flags
  The randomizer supports a number of options, documented in detail
  at https://crystalisrandomizer.com.  Spaces are ignored.

Presets
${Preset.all().map(showPreset).join('\n\n')}`);
    process.exit(code);
};
const showPreset = ({ description, flagString, name }) => {
    const LINE_LENGTH = 68;
    const flagLen = LINE_LENGTH - name.length - 6;
    const flagLines = breakLines(flagString, flagLen);
    const descrLines = breakLines(description, LINE_LENGTH - 2);
    const indent = '\n' + ' '.repeat(name.length + 5);
    return `  ${name}: "${flagLines.join(indent)}"
  ${descrLines.join('\n  ')}`;
};
const main = (...args) => {
    let flags = '@Standard';
    let count = 1;
    let seed = '';
    let output = '%n_%c';
    let force = false;
    while (args[0] && args[0].startsWith('--')) {
        let arg = args.shift().substring(2);
        let value = undefined;
        const eq = arg.indexOf('=');
        if (eq >= 0) {
            value = arg.substring(eq + 1);
            arg = arg.substring(0, eq);
        }
        else {
            value = args.shift();
        }
        if (arg == 'flags' && value) {
            flags = value;
        }
        else if (arg == 'preset' && value) {
            flags = '@' + value.replace(/ /g, '');
        }
        else if (arg == 'output' && value) {
            output = value;
        }
        else if (arg == 'seed' && value) {
            seed = value;
        }
        else if (arg == 'count' && value) {
            count = Number(value);
        }
        else if (arg == 'force') {
            force = true;
            disableAsserts();
            if (value != null)
                args.unshift(value);
        }
        else if (arg == 'help') {
            usage(0);
        }
        else if (arg == 'version' || arg == '-v') {
            console.log(version.VERSION);
            process.exit(0);
        }
        else if (arg == 'list-presets') {
            for (const { name } of Preset.all()) {
                console.log(name.replace(/ /g, ''));
            }
            process.exit(0);
        }
        else {
            console.error(`Bad argument: ${arg}`);
            usage(1);
        }
    }
    if (args.length != 1)
        usage(1);
    if (count > 1) {
        if (seed)
            fail('Cannot specify both --count and --seed');
        if (!/%[sc]/.test(output)) {
            fail('--output must have a %c or %s placeholder when --count is given');
        }
    }
    const flagset = new FlagSet(flags);
    const rom = new Uint8Array(fs.readFileSync(args[0]).buffer);
    if (crc32(rom) != EXPECTED_CRC32) {
        console.error(`WARNING: Bad CRC for input rom: ${crc32(rom).toString(16)}`);
        if (!force)
            fail('Run with --force to proceed anyway');
        console.error('Proceeding anyway');
    }
    return Promise.all(new Array(count).fill(0).map(async () => {
        const s = patch.parseSeed(seed);
        console.log(`Seed: ${s.toString(16)}`);
        const orig = rom.slice();
        const [shuffled, c] = await patch.shuffle(orig, s, flagset, new NodeReader());
        const n = args[0].replace('.nes', '');
        const f = String(flagset).replace(/ /g, '');
        const v = version.VERSION;
        const filename = fillTemplate(output, { c, n, s, v, f, '%': '%' }) + '.nes';
        await new Promise((resolve, reject) => fs.writeFile(filename, shuffled, (err) => err ? reject(err) : resolve()));
        console.log(`Wrote ${filename}`);
    }));
};
function fail(message) {
    console.error(message);
    throw process.exit(2);
}
function fillTemplate(str, arg) {
    const terms = [];
    while (str) {
        const index = str.indexOf('%');
        if (index < 0) {
            terms.push(str);
            str = '';
        }
        else {
            terms.push(str.substring(0, index));
            const ch = str[index + 1];
            if (!(ch in arg))
                throw new Error(`Bad placeholder: %${ch}`);
            terms.push(arg[ch]);
            str = str.substring(index + 2);
        }
    }
    return terms.join('');
}
process.on('unhandledRejection', (error) => {
    console.error(typeof error === 'string' ?
        error :
        error instanceof UsageError ? error.message : error.stack);
    process.exit(1);
});
const asyncMain = async () => {
    try {
        await main(...process.argv.slice(2));
    }
    catch (error) {
        if (error instanceof UsageError) {
            console.error(error.message);
            console.error(`Try passing --help for documentation.`);
            process.exit(1);
        }
        throw error;
    }
};
asyncMain().then(() => process.exit(0));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xpLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2pzL2NsaS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBRUEsT0FBTyxpQkFBaUIsQ0FBQztBQUV6QixPQUFPLEVBQUMsY0FBYyxFQUFDLE1BQU0sVUFBVSxDQUFDO0FBQ3hDLE9BQU8sRUFBQyxPQUFPLEVBQUUsTUFBTSxFQUFDLE1BQU0sY0FBYyxDQUFDO0FBQzdDLE9BQU8sRUFBQyxLQUFLLEVBQUMsTUFBTSxZQUFZLENBQUM7QUFDakMsT0FBTyxLQUFLLEVBQUUsTUFBTSxJQUFJLENBQUM7QUFDekIsT0FBTyxLQUFLLEtBQUssTUFBTSxZQUFZLENBQUM7QUFDcEMsT0FBTyxFQUFDLFVBQVUsRUFBRSxVQUFVLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFDakQsT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLGlCQUFpQixDQUFDO0FBQzNDLE9BQU8sS0FBSyxPQUFPLE1BQU0sY0FBYyxDQUFDO0FBQ3hDLE9BQU8sRUFBQyxjQUFjLEVBQUMsTUFBTSxhQUFhLENBQUM7QUFJM0MsTUFBTSxLQUFLLEdBQUcsQ0FBQyxJQUFZLEVBQUUsRUFBRTtJQUM3QixPQUFPLENBQUMsR0FBRyxDQUFDLHlCQUF5QixPQUFPLENBQUMsT0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBMkJwRCxNQUFNLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDN0MsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNyQixDQUFDLENBQUM7QUFFRixNQUFNLFVBQVUsR0FBRyxDQUFDLEVBQUMsV0FBVyxFQUFFLFVBQVUsRUFBRSxJQUFJLEVBQVMsRUFBRSxFQUFFO0lBQzdELE1BQU0sV0FBVyxHQUFHLEVBQUUsQ0FBQztJQUN2QixNQUFNLE9BQU8sR0FBRyxXQUFXLEdBQUcsSUFB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O0tBQ0Y7SUFDRCxPQUFPLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDeEIsQ0FBQztBQUVELE9BQU8sQ0FBQyxFQUFFLENBQUMsb0JBQW9CLEVBQUUsQ0FBQyxLQUFVLEVBQUUsRUFBRTtJQUM5QyxPQUFPLENBQUMsS0FBSyxDQUNULE9BQU8sS0FBSyxLQUFLLFFBQVEsQ0FBQyxDQUFDO1FBQ3ZCLEtBQUssQ0FBQyxDQUFDO1FBQ1AsS0FBSyxZQUFZLFVBQVUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ25FLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDbEIsQ0FBQyxDQUFDLENBQUM7QUFFSCxNQUFNLFNBQVMsR0FDWCxLQUFLLElBQUksRUFBRTtJQUNiLElBQUk7UUFDRixNQUFNLElBQUksQ0FBQyxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDdEM7SUFBQyxPQUFPLEtBQUssRUFBRTtRQUNkLElBQUksS0FBSyxZQUFZLFVBQVUsRUFBRTtZQUMvQixPQUFPLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUM3QixPQUFPLENBQUMsS0FBSyxDQUFDLHVDQUF1QyxDQUFDLENBQUM7WUFDdkQsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNqQjtRQUNELE1BQU0sS0FBSyxDQUFDO0tBQ2I7QUFDSCxDQUFDLENBQUE7QUFFRCxTQUFTLEVBQUUsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiIyEvdXNyL2Jpbi9lbnYgbm9kZSAtciBlc21cblxuaW1wb3J0ICcuL2J1aWxkX2luZm8uanMnOyAvLyBzaWRlIGVmZmVjdCBnbG9iYWwgc2V0IChhZmZlY3RzIHZlcnNpb24gbW9kdWxlKVxuXG5pbXBvcnQge0VYUEVDVEVEX0NSQzMyfSBmcm9tICcuL3JvbS5qcyc7XG5pbXBvcnQge0ZsYWdTZXQsIFByZXNldH0gZnJvbSAnLi9mbGFnc2V0LmpzJztcbmltcG9ydCB7Y3JjMzJ9IGZyb20gJy4vY3JjMzIuanMnO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xuaW1wb3J0ICogYXMgcGF0Y2ggZnJvbSAnLi9wYXRjaC5qcyc7XG5pbXBvcnQge1VzYWdlRXJyb3IsIGJyZWFrTGluZXN9IGZyb20gJy4vdXRpbC5qcyc7XG5pbXBvcnQge05vZGVSZWFkZXJ9IGZyb20gJy4vbm9kZXJlYWRlci5qcyc7XG5pbXBvcnQgKiBhcyB2ZXJzaW9uIGZyb20gJy4vdmVyc2lvbi5qcyc7XG5pbXBvcnQge2Rpc2FibGVBc3NlcnRzfSBmcm9tICcuL2Fzc2VydC5qcyc7XG5cbi8vIFVzYWdlOiBub2RlIGNsaS5qcyBbLS1mbGFncz08RkxBR1M+XSBbLS1zZWVkPTxTRUVEPl0gcm9tLm5lc1xuXG5jb25zdCB1c2FnZSA9IChjb2RlOiBudW1iZXIpID0+IHtcbiAgY29uc29sZS5sb2coYENyeXN0YWxpcyBSYW5kb21pemVyIHYke3ZlcnNpb24uVkVSU0lPTn1cblVzYWdlOiBjcnlyIFtPUFRJT05TLi4uXSByb20ubmVzXG5cbk9wdGlvbnNcbiAgLS1mbGFncz1GTEFHU0VUICAgIFNwZWNpZnkgdGhlIGZsYWdzZXQuXG4gIC0tcHJlc2V0PVBSRVNFVCAgICBTcGVjaWZ5IHRoZSBwcmVzZXQgYnkgbmFtZS5cbiAgICAgICAgICAgICAgICAgICAgIFNwYWNlcyBhbmQgY2FwaXRhbGl6YXRpb24gYXJlIGlnbm9yZWQuXG4gIC0tc2VlZD1TRUVEICAgICAgICBTcGVjaWZ5IHRoZSBzZWVkLlxuICAtLW91dHB1dD1QQVRURVJOICAgU3BlY2lmeSB0aGUgb3V0cHV0IGZpbGVuYW1lIHBhdHRlcm4uXG4gICAgICAgICAgICAgICAgICAgICBNYXkgaW5jbHVkZSBwbGFjZWhvbGRlcnM6XG4gICAgICAgICAgICAgICAgICAgICAgICVuOiBpbnB1dCBiYXNlIGZpbGVuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICV2OiBjcnlyIHZlcnNpb24gaGFzaFxuICAgICAgICAgICAgICAgICAgICAgICAlczogc2VlZFxuICAgICAgICAgICAgICAgICAgICAgICAlZjogZmxhZ3NldFxuICAgICAgICAgICAgICAgICAgICAgICAlYzogY2hlY2tzdW1cbiAgICAgICAgICAgICAgICAgICAgIFRoZSBkZWZhdWx0IHBhdHRlcm4gaXMgXCIlbl8lY1wiLlxuICAtLWNvdW50PU5VTUJFUiAgICAgTnVtYmVyIG9mIHNodWZmbGVkIHJvbXMgdG8gZ2VuZXJhdGUuXG4gICAgICAgICAgICAgICAgICAgICBUaGlzIGZsYWcgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBzcGVjaWZ5aW5nXG4gICAgICAgICAgICAgICAgICAgICBhIHNlZWQgbWFudWFsbHksIG5vciB3aXRoIG91dHB1dCBwYXR0ZXJuc1xuICAgICAgICAgICAgICAgICAgICAgdGhhdCBkb24ndCBpbmNsdWRlICVzIG9yICVjLlxuICAtLWZvcmNlICAgICAgICAgICAgRG9uJ3QgZmFpbCBkdWUgdG8gd3JvbmcgaW5wdXQgZmlsZSBjaGVja3N1bS5cblxuRmxhZ3NcbiAgVGhlIHJhbmRvbWl6ZXIgc3VwcG9ydHMgYSBudW1iZXIgb2Ygb3B0aW9ucywgZG9jdW1lbnRlZCBpbiBkZXRhaWxcbiAgYXQgaHR0cHM6Ly9jcnlzdGFsaXNyYW5kb21pemVyLmNvbS4gIFNwYWNlcyBhcmUgaWdub3JlZC5cblxuUHJlc2V0c1xuJHtQcmVzZXQuYWxsKCkubWFwKHNob3dQcmVzZXQpLmpvaW4oJ1xcblxcbicpfWApO1xuICBwcm9jZXNzLmV4aXQoY29kZSk7XG59O1xuXG5jb25zdCBzaG93UHJlc2V0ID0gKHtkZXNjcmlwdGlvbiwgZmxhZ1N0cmluZywgbmFtZX06IFByZXNldCkgPT4ge1xuICBjb25zdCBMSU5FX0xFTkdUSCA9IDY4O1xuICBjb25zdCBmbGFnTGVuID0gTElORV9MRU5HVEggLSBuYW1lLmxlbmd0aCAtIDY7XG4gIGNvbnN0IGZsYWdMaW5lcyA9IGJyZWFrTGluZXMoZmxhZ1N0cmluZywgZmxhZ0xlbik7XG4gIGNvbnN0IGRlc2NyTGluZXMgPSBicmVha0xpbmVzKGRlc2NyaXB0aW9uLCBMSU5FX0xFTkdUSCAtIDIpO1xuICBjb25zdCBpbmRlbnQgPSAnXFxuJyArICcgJy5yZXBlYXQobmFtZS5sZW5ndGggKyA1KTtcbiAgcmV0dXJuIGAgICR7bmFtZX06IFwiJHtmbGFnTGluZXMuam9pbihpbmRlbnQpfVwiXG4gICR7ZGVzY3JMaW5lcy5qb2luKCdcXG4gICcpfWA7XG59O1xuXG5jb25zdCBtYWluID0gKC4uLmFyZ3M6IHN0cmluZ1tdKSA9PiB7XG4gIGxldCBmbGFncyA9ICdAU3RhbmRhcmQnO1xuICBsZXQgY291bnQgPSAxO1xuICBsZXQgc2VlZCA9ICcnO1xuICBsZXQgb3V0cHV0ID0gJyVuXyVjJztcbiAgbGV0IGZvcmNlID0gZmFsc2U7XG4gIHdoaWxlIChhcmdzWzBdICYmIGFyZ3NbMF0uc3RhcnRzV2l0aCgnLS0nKSkge1xuICAgIGxldCBhcmcgPSBhcmdzLnNoaWZ0KCkhLnN1YnN0cmluZygyKTtcbiAgICBsZXQgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgY29uc3QgZXEgPSBhcmcuaW5kZXhPZignPScpO1xuICAgIGlmIChlcSA+PSAwKSB7XG4gICAgICB2YWx1ZSA9IGFyZy5zdWJzdHJpbmcoZXEgKyAxKTtcbiAgICAgIGFyZyA9IGFyZy5zdWJzdHJpbmcoMCwgZXEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IGFyZ3Muc2hpZnQoKTtcbiAgICB9XG4gICAgaWYgKGFyZyA9PSAnZmxhZ3MnICYmIHZhbHVlKSB7XG4gICAgICBmbGFncyA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAoYXJnID09ICdwcmVzZXQnICYmIHZhbHVlKSB7XG4gICAgICBmbGFncyA9ICdAJyArIHZhbHVlLnJlcGxhY2UoLyAvZywgJycpO1xuICAgIH0gZWxzZSBpZiAoYXJnID09ICdvdXRwdXQnICYmIHZhbHVlKSB7XG4gICAgICBvdXRwdXQgPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKGFyZyA9PSAnc2VlZCcgJiYgdmFsdWUpIHtcbiAgICAgIHNlZWQgPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKGFyZyA9PSAnY291bnQnICYmIHZhbHVlKSB7XG4gICAgICBjb3VudCA9IE51bWJlcih2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChhcmcgPT0gJ2ZvcmNlJykge1xuICAgICAgZm9yY2UgPSB0cnVlO1xuICAgICAgZGlzYWJsZUFzc2VydHMoKTtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSBhcmdzLnVuc2hpZnQodmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoYXJnID09ICdoZWxwJykge1xuICAgICAgdXNhZ2UoMCk7XG4gICAgfSBlbHNlIGlmIChhcmcgPT0gJ3ZlcnNpb24nIHx8IGFyZyA9PSAnLXYnKSB7XG4gICAgICBjb25zb2xlLmxvZyh2ZXJzaW9uLlZFUlNJT04pO1xuICAgICAgcHJvY2Vzcy5leGl0KDApO1xuICAgIH0gZWxzZSBpZiAoYXJnID09ICdsaXN0LXByZXNldHMnKSB7XG4gICAgICAvLyB1bmRvY3VtZW50ZWQgZmxhZ1xuICAgICAgZm9yIChjb25zdCB7bmFtZX0gb2YgUHJlc2V0LmFsbCgpKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKG5hbWUucmVwbGFjZSgvIC9nLCAnJykpO1xuICAgICAgfVxuICAgICAgcHJvY2Vzcy5leGl0KDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBCYWQgYXJndW1lbnQ6ICR7YXJnfWApO1xuICAgICAgdXNhZ2UoMSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGFyZ3MubGVuZ3RoICE9IDEpIHVzYWdlKDEpO1xuICBpZiAoY291bnQgPiAxKSB7XG4gICAgaWYgKHNlZWQpIGZhaWwoJ0Nhbm5vdCBzcGVjaWZ5IGJvdGggLS1jb3VudCBhbmQgLS1zZWVkJyk7XG4gICAgaWYgKCEvJVtzY10vLnRlc3Qob3V0cHV0KSkge1xuICAgICAgZmFpbCgnLS1vdXRwdXQgbXVzdCBoYXZlIGEgJWMgb3IgJXMgcGxhY2Vob2xkZXIgd2hlbiAtLWNvdW50IGlzIGdpdmVuJyk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgZmxhZ3NldCA9IG5ldyBGbGFnU2V0KGZsYWdzKTtcbiAgY29uc3Qgcm9tID0gbmV3IFVpbnQ4QXJyYXkoZnMucmVhZEZpbGVTeW5jKGFyZ3NbMF0pLmJ1ZmZlcik7XG4gIGlmIChjcmMzMihyb20pICE9IEVYUEVDVEVEX0NSQzMyKSB7XG4gICAgY29uc29sZS5lcnJvcihgV0FSTklORzogQmFkIENSQyBmb3IgaW5wdXQgcm9tOiAke2NyYzMyKHJvbSkudG9TdHJpbmcoMTYpfWApO1xuICAgIGlmICghZm9yY2UpIGZhaWwoJ1J1biB3aXRoIC0tZm9yY2UgdG8gcHJvY2VlZCBhbnl3YXknKTtcbiAgICBjb25zb2xlLmVycm9yKCdQcm9jZWVkaW5nIGFueXdheScpO1xuICB9XG5cbiAgcmV0dXJuIFByb21pc2UuYWxsKG5ldyBBcnJheShjb3VudCkuZmlsbCgwKS5tYXAoYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHMgPSBwYXRjaC5wYXJzZVNlZWQoc2VlZCk7XG4gICAgY29uc29sZS5sb2coYFNlZWQ6ICR7cy50b1N0cmluZygxNil9YCk7XG4gICAgY29uc3Qgb3JpZyA9IHJvbS5zbGljZSgpO1xuICAgIGNvbnN0IFtzaHVmZmxlZCwgY10gPVxuICAgICAgICBhd2FpdCBwYXRjaC5zaHVmZmxlKG9yaWcsIHMsIGZsYWdzZXQsIG5ldyBOb2RlUmVhZGVyKCkpO1xuICAgIGNvbnN0IG4gPSBhcmdzWzBdLnJlcGxhY2UoJy5uZXMnLCAnJyk7XG4gICAgY29uc3QgZiA9IFN0cmluZyhmbGFnc2V0KS5yZXBsYWNlKC8gL2csICcnKTtcbiAgICBjb25zdCB2ID0gdmVyc2lvbi5WRVJTSU9OO1xuICAgIGNvbnN0IGZpbGVuYW1lID0gZmlsbFRlbXBsYXRlKG91dHB1dCwge2MsIG4sIHMsIHYsIGYsICclJzogJyUnfSkgKyAnLm5lcyc7XG4gICAgYXdhaXQgbmV3IFByb21pc2UoXG4gICAgICAgIChyZXNvbHZlLCByZWplY3QpID0+IGZzLndyaXRlRmlsZShcbiAgICAgICAgICAgIGZpbGVuYW1lLCBzaHVmZmxlZCwgKGVycikgPT4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKCkpKTtcbiAgICBjb25zb2xlLmxvZyhgV3JvdGUgJHtmaWxlbmFtZX1gKTtcbiAgfSkpO1xufTtcblxuZnVuY3Rpb24gZmFpbChtZXNzYWdlOiBzdHJpbmcpOiBuZXZlciB7XG4gIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gIHRocm93IHByb2Nlc3MuZXhpdCgyKTtcbn1cblxuZnVuY3Rpb24gZmlsbFRlbXBsYXRlKHN0cjogc3RyaW5nLCBhcmc6IHtba2V5OiBzdHJpbmddOiB1bmtub3dufSk6IHN0cmluZyB7XG4gIGNvbnN0IHRlcm1zID0gW107XG4gIHdoaWxlIChzdHIpIHtcbiAgICBjb25zdCBpbmRleCA9IHN0ci5pbmRleE9mKCclJyk7XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgdGVybXMucHVzaChzdHIpO1xuICAgICAgc3RyID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRlcm1zLnB1c2goc3RyLnN1YnN0cmluZygwLCBpbmRleCkpO1xuICAgICAgY29uc3QgY2ggPSBzdHJbaW5kZXggKyAxXTtcbiAgICAgIGlmICghKGNoIGluIGFyZykpIHRocm93IG5ldyBFcnJvcihgQmFkIHBsYWNlaG9sZGVyOiAlJHtjaH1gKTtcbiAgICAgIHRlcm1zLnB1c2goYXJnW2NoXSk7XG4gICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKGluZGV4ICsgMik7XG4gICAgfVxuICB9XG4gIHJldHVybiB0ZXJtcy5qb2luKCcnKTtcbn1cblxucHJvY2Vzcy5vbigndW5oYW5kbGVkUmVqZWN0aW9uJywgKGVycm9yOiBhbnkpID0+IHtcbiAgY29uc29sZS5lcnJvcihcbiAgICAgIHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycgP1xuICAgICAgICAgIGVycm9yIDpcbiAgICAgICAgICBlcnJvciBpbnN0YW5jZW9mIFVzYWdlRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogZXJyb3Iuc3RhY2spO1xuICBwcm9jZXNzLmV4aXQoMSk7XG59KTtcblxuY29uc3QgYXN5bmNNYWluID1cbiAgICBhc3luYyAoKSA9PiB7XG4gIHRyeSB7XG4gICAgYXdhaXQgbWFpbiguLi5wcm9jZXNzLmFyZ3Yuc2xpY2UoMikpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFVzYWdlRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgICBjb25zb2xlLmVycm9yKGBUcnkgcGFzc2luZyAtLWhlbHAgZm9yIGRvY3VtZW50YXRpb24uYCk7XG4gICAgICBwcm9jZXNzLmV4aXQoMSk7XG4gICAgfVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbmFzeW5jTWFpbigpLnRoZW4oKCkgPT4gcHJvY2Vzcy5leGl0KDApKTtcbiJdfQ==