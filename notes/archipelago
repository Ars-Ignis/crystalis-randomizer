Archipelago - (#future-game-design 6/9/2022 20:45 ET)

so yeah in AP you can use the generate_output step and just call your patcher and you'll have full access to all the data for the seed

https://github.com/PiotrDabkowski/Js2Py

secret of evermore is python wrapped around C
i think it only writes in the locations where if it doesn't put an item there everything breaks
the rest it leaves as an empty "AP item" and if its their own item they just receive it from the server like any other item
you cant have unfilled locations

it's very possible you'll have spots you'll need to fill before generation. anything done before or in generate_basic is before the actual fill step
the actual kind of "do this in this step" hasn't really been formalized yet but there's plenty of examples
it is, read api.md
i'd definitely recommend referencing both SoE and TS for your world though
api.md just kind of covers what the different steps do but you don't really have to use them though probably should

there's steps to help with stuff such as map generation but you should probably do that in generate_early so if you need to crash it's quick
the item shuffle would be done by AP anyway, so only your special stuff really matters
that's ok, but you should retry early
as in realize no sphere 1 is reachable and retry; before AP goes into item placement
because AP does that step once only
and expects it to work then
one idea would be to quickly verify with a single-world item placement
yeah that has to be done before AP starts its filling
you can make a state object with no items and check accessible locations
you can just get reachable locations through AP and see if its 0
since you need to encode it for AP anyway
this will also allow you to check if there's a small number (<5 or such) available checks and force an early item

======

Serializing ROM object
 - could use JSON or protobuf
 - move expanded PRG to start
 - output actual patch (could auto-apply in UI)
 - add a hash as well for optional checksum
 - find-replace ($|0x)3[cdef]\x{3} with 3->7

Client
 - knowing which parts of memory are important to check

======

Dealing with the ROM input issue:
 - a two-pass shuffle would allow minimizing the data in
   the serialized Rom object.
What is the required input/output of a pre-shuffle?
Inputs:
 - Imported labels that must be provided elsewhere
Outputs:
 - (serialized) Rom
   - possibly just map of extracted data tables
 - Map of exported labels to address
 - Map of where the imported labels show up
 - The patched ROM itself, obvi

This will prevent optimizing the free space, but we could
potentially be very efficient about defragging early on?
If there's only a single large chunk of free space in each
block then we can dispense with the fancy linker and just
write stupidly.


======

Notes from CodeGorilla:

Decided to take an alternate approach to the above, with some pros and cons. The basic
approach is as follows:

1. Use a modified version of the randomizer code to get a list of all items and locations
   with the exact names and in-memory IDs (Done)
2. Make a list of Regions and Entrances between Regions (using the AP definition in both 
   cases). Regions (AP) end up being smaller than Areas (this codebase), mainly to be able
   to properly support randomized wild warp. (Done)
3. Write out pseudologic for every Entrance and Location. (Tedious, but done)
4. Write code to convert the above spreadsheets into JSON. (Done)
5. Read the JSON in the AP codebase. (Done)
6. Create all of the necessary logic rules by hand in AP (Done, though admittedly not 
   heavily tested)
7. Create a ShuffleData structure that keeps track of all the things AP needs to randomize
   (i.e. randomizations that affect logic). (Done)
8. Put that data in an .apcrys file as part of the AP generate_output step. (Done)
9. Make a new entry point into this codebase that can read that output file and force 
   matching choices instead of randomization in the ROM patching process. (Done)
10.Write client code that can check the status of various locations. (Done-ish; mimics still
   a problem.)
11.Write ASM code that allows arbitrary item granting from the client (hopefully including
   mimics).
12.Make a new web interface that accepts a vanilla ROM and an .apcrys file and uses the new
   entry point to patch accordingly.

As mentioned, there are some pros and cons to this approach:
Pros:
  - Romless generation. AP core devs are generally pushing ROM games towards this approach 
    where possible. This allows AP hosts more ability to generate games, which makes it much
	easier for Crystalis to be played (and tested)
  - Taking advantage of the full power of AP's Region system for the logic graph. More
    generally, by building the Regions and Entrances (and associated logic) by hand, we can
	optimize it's shape specifically for the AP fill algorithm.
  - Genereralized Entrance Randomization. Archipelago has (or will have soon) a generalized
    algorithm for randomizing entrances. This algorithm supports grouping of entrances, which
	means we'll be able to use it for both house and area shuffle. (Goa shuffle may still
	need special handling, due to invalid combinations of floors.)
  - Easier to read and maintain. The approach which wrapped all of Crystalis Randomizer into 
    a single file and then called into it from Python code resulted in a file over 100K lines 
	long. Getting that reviewed in a code review when eventually PR'ing to AP core (should that 
	happen) seems highly improbable.

Cons:
  - Error prone. While I'm reasonably confident in the implementation of the logic, it's
    certainly more likely to fail than reading the logic directly from the randomizer itself.
  - Potentially results in divergent codebases. Again, while I'm trying to maintain parity
    with this codebase, any logic change in the base randomizer now necessitates a mirrored
	change in the .apworld. This can be particularly problematic if this .apworld is accepted
	by the AP Core devs, as that ties .apworld changes down to AP's release schedule.
  - Extra website step is not ideal UX for the player. It adds an extra roadblock to playing,
    and works differently to most other ROM games. (That said, there is precedent in the Final
	Fantasy Mystic Quest implementation.
  - Some features may be too complex to represent in the .apcrys file. In particular, I'm not
    currently sure how to implement Wm - randomize maps - in a way that the logic can be read 
	reasonably and a representation can be sent to this codebase to rearrange the map in the
	way logic expects.

In my opinion, the pros overall outweigh the cons, hence why I settled on this approach, but
I could certainly see another developer taking a different approach.

Feature To-Do list:
  -User-facing documentation
  -better mimic spawning? (actually very important; things can glitch out spectacularly otherwise)
  -logic and implementation of flags not yet implemented:
	-Wg (probably bespoke randomization, for such a small list)
	
	-Et (remove mimic locations from AP's location set)
	-Eu (remove consumable locations from AP's location set)
	
	-Gr (force a flier in the Lime Valley enemy pool? not sure on this one - CR-side only) 
	
    -Wa, Wh (using GER)
    -Wm (not a clue; implementation TBD, not in initial release)
  -Archipelago specific features:
    -Deathlink >:)
	-Gifting interface? (maybe take over pawn-shops?)
	-Option for local items being baked into the ROM? (Probably not, given how item flags end up working, but you never know)