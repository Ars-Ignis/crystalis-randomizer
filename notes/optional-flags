# Optional Flags

Goal: Compute a checksum BEFORE applying selected edits to the Rom object.

## Problem

Currently the data flow looks like this:
  1. Given (prg: Uint8Array)
  2. Apply deterministicPreParse(prg)
  3. Apply preshuffle.s (computes addresses required by rom parser)
  4. Parse the rom -> (rom: Rom)
  5. Defrag the flags (may not matter?)
  6. Apply postparse.s (clobbers tables read by rom parser)
  7. Edit rom object
  8. Write rom object data -> prg
  9. Write a few additional things into prg (including random number shuffle
     and applying postshuffle.s)
 10. Compute checksum, stamp into various spots, return

This is bad because edits are all over the place rather than contained - some
edits go directly to the PRG, some clobber others, etc.  Worse, there are
meaningul changes after the data is written back, which means we can't edit
the rom object at that point.

## Solution

What we need to do is consolidate this so that
 * all writes go into the object throughout the entire process (including asm).
 * writing the rom data is idempotent.  We could write to a different object.

Alternatively we could add a "hash" function to everything in the rom.  Keeping
the writes idempotent seems like an easier invariant to maintain, though it will
require duplicating work since we'll need to serialize the entire rom object
twice.

The new data flow should be:
  1. Apply deterministicPreParse(prg)  <- this is okay if it's deterministic
  2. Parse the rom -> (rom: Rom)
  3. Defrag the flags
  4. Edit the rom object
  5. Apply all the asm
  6. Write rom -> fake prg, compute and stamp checksum
  7. Apply optional flags
  8. Write rom -> actual prg and return

This requires adding "raw chunks" to the Rom object?  They will be written
later.  As long as they're not actually *read* from the PRG, it should be
fine?

## Late code writes

An interesting consequence here is that we could actually share PRG allocations
between code and data.  It would require a new directive in the assembler:

```
.block $1c000:$1dfff
```

This would last until the next `.block` or `.org` and would allow a normal
writer to optimize placement.  One difficulty here is that the assembler
currently assumes it knows where something is during the initial parse,
and this would break that assumption, so it would need some rearchitecting.
Blocks would need to have a separate label space, and would store the offset
of each label.  There's also a dependency graph, where dependency blocks need
to be written first so that their address is available to dependents.

We could store a promise in the label slot, and write them early/eagerly.
Detecting cycles might be difficult.

## TODO

1. Find all write() functions in rom - ensure no state changes
2. Find all reads from rom.prg - ensure they all happen at parse time
3. Find all writes to rom.prg - pull out into a dedicated rom child
4. Teach assembler a new directive, new label structure (with deps)
5. Teach assembler to write using a new interface: block => Promise<number>
