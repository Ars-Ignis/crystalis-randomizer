bits: 7 => knockback
      5,6 => direction resolution (8/16/32/64)
      0..4 => speed


0 => 1/4
31 => 8

Given step count S (0..7), speed v at 1/4 resolution (0..31)
sin/cos tables at 1/64 resolution c,s (0..63)

dx = c*(S+1)*v


64 directions -> 16 entries to sin table
16 angles * 32 speeds = 512 bytes, on 0..31 scale (1/4)?
  - ultimately need 1/8 resolution => 0..63
Multiply by 0..7 -> 9 bits (use carry?)

  ;; Step should be in the upper 3 bits
  asl Step
  asl Step
  asl Step
  asl Step
  asl Step
  ;; Do the multiplication
  lda Frac  ; 0..63
  sta $61
  lda Step  ; 0..7
  sta $62
  lda #$00
  
  asl $62



Vanilla:
 340 = RRRRSSSS  recoil position, speed
 360 = KKKKDDDD  knockback direction, direction
Proposed:
 340 = RMMSSSSS  recoil position, mode, speed
 360 = KKKDDDDD or 00DDDDDD depending on mode?

But how do we reduce recoil to a single bit???



Note that ComputeDisplacementVector is called 20 times:
 _1e8ff: giant insect
 _1ea37: kelbesque
 BossPatternJump_18: sabera
 _1eeba: mado
 _1f203: draygon
 CheckDirectionAgainstTerrain: player and mobs
 ObjectActionJump_54: following dwarf child
 ObjectActionJump_2b: mimic
 ObjectActionJump_30 (@FinishNpcAction): npc
 ObjectActionJump_32 (@advance_frame): movement script
 ObjectActionJump_38: moving platform
 ObjectActionJump_57: dyna shots (bubble and revenge beam)
 ObjectActionJump_1b: boss popcorn
 ObjectActionJump_12: tornado
 ObjectActionJump_13: blizzard
 ObjectActionJump_15: fire 2
 ObjectActionJump_40: bats/moths
 ObjectActionJump_44: tomato
 ObjectActionJump_45: basic flyer
 FinishRobotMovement: robots (helicopter, maybe?)


There are 196 references (102 writes) to $0340,x (speed) or $0360,x (direction)
 - all of these will need updating...!


# ObjectDirection\|\$0?3[67][0-9a-f]  in 00000..20000
 * call VectorBetweenObjectsXY then read $20 => $360,x
    - vampire 7, kelbeqsue 1
 * call VectorBetweenObjectsXY then transform => $360,x
    - (<<1) (+/-1): _1e96b (kelby rock? action) - 16-dir
    - (<<1) (+1) (+dir) (&f) (index _1ed86 +/-1,0) (+dir) (&f): sabera 1
    - (<<1): sabera 1 
 * read to A before calling ComputeDisplacementVector
    - insect 1 (_1e8ff), kelbesque 1 (_1ea37), sabera 1, mado 3 (_1eeba)
    
 * reverse 8-dir
    - _1e602, kelbesque 3, 
 * initialize to zero
    - sabera 0
 * hardcode 2 or 6
    - insect 1
 * set to ~random 16-dir from a table
    - mado 3 (table 1ef28)
 * special handling for kelbesque 2
    - or w/ #$04
    - write from data table _1ea97 (1, 0, or 7) or _1ea37 (3, 4, or 5) or hardcoded 0
 * _1eb96 (object action 64, kelby rock)
    - adds $20<<1 from a much earlier VectorBetweenObjectsXY (to switch to 16-dir?)
 * _1ed96 (sabera 1)
    - added to ($620>>4)-2, (&f) => y (direction) then call AdHocSpawnObject
 * copy from $1f
    - mado 5, initializing half the adhoc-spawned shurikens (other half from Y)
 * karmine
    - (karmine 1) set to 0 or 4 from $301<<2 (`and #$06` might as well be `and #$04`??)
    - (karmine 2) set to exactly 8?

NOTE: gave up at Draygon 1
NOTE: also need to pay attention to _all_ AdHocSpawnObject calls -> how is Y initialized?

VectorBetweenObjectsXY =>
 - will want to have a high-res version of this?



============

How does knockback play into $360?
 - PlayerHit_CalculateDamage zeroes out the high nibble of 361 and copies 3[46]1 to 3[46]0
 - PlayerHit_ApplyKnockback temporarily replaces player's speed/dir with 2/dir[obj] to bump,
   then restores
 - _35535 temporarily swaps direction to south for statue bump
 - KnockbackObject puts the 8-dir of the $11 object into the upper nibble of $10's dir
    - it's called in three places:
      (1) AttackEnemy_Immune, (2) AttackEnemy_DealDamage, (3) PlayerHit_CalculateDamage
    - the use of x vs y is swapped in these, unfortunately, so there's extra code to save
      and restore...
