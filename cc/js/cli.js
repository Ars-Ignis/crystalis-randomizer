#!/usr/bin/env -S node -r esm --inspect 
import './build_info.js';
import { EXPECTED_CRC32 } from './rom.js';
import { FlagSet, Preset } from './flagset.js';
import { crc32 } from './crc32.js';
import * as fs from 'fs';
import * as patch from './patch.js';
import { UsageError, breakLines } from './util.js';
import { NodeReader } from './nodereader.js';
import * as version from './version.js';
import { disableAsserts } from './assert.js';
const usage = (code) => {
    console.log(`Crystalis Randomizer v${version.VERSION}
Usage: cryr [OPTIONS...] rom.nes

Options
  --flags=FLAGSET    Specify the flagset.
  --preset=PRESET    Specify the preset by name.
                     Spaces and capitalization are ignored.
  --seed=SEED        Specify the seed.
  --output=PATTERN   Specify the output filename pattern.
                     May include placeholders:
                       %n: input base filename
                       %v: cryr version hash
                       %s: seed
                       %f: flagset
                       %c: checksum
                     The default pattern is "%n_%c".
  --count=NUMBER     Number of shuffled roms to generate.
                     This flag is not compatible with specifying
                     a seed manually, nor with output patterns
                     that don't include %s or %c.
  --force            Don't fail due to wrong input file checksum.

Flags
  The randomizer supports a number of options, documented in detail
  at https://crystalisrandomizer.com.  Spaces are ignored.

Presets
${Preset.all().map(showPreset).join('\n\n')}`);
    process.exit(code);
};
const showPreset = ({ description, flagString, name }) => {
    const LINE_LENGTH = 68;
    const flagLen = LINE_LENGTH - name.length - 6;
    const flagLines = breakLines(flagString, flagLen);
    const descrLines = breakLines(description, LINE_LENGTH - 2);
    const indent = '\n' + ' '.repeat(name.length + 5);
    return `  ${name}: "${flagLines.join(indent)}"
  ${descrLines.join('\n  ')}`;
};
const main = (...args) => {
    let flags = '@Standard';
    let count = 1;
    let seed = '';
    let output = '%n_%c';
    let force = false;
    while (args[0] && args[0].startsWith('--')) {
        let arg = args.shift().substring(2);
        let value = undefined;
        const eq = arg.indexOf('=');
        if (eq >= 0) {
            value = arg.substring(eq + 1);
            arg = arg.substring(0, eq);
        }
        else {
            value = args.shift();
        }
        if (arg == 'flags' && value) {
            flags = value;
        }
        else if (arg == 'preset' && value) {
            flags = '@' + value.replace(/ /g, '');
        }
        else if (arg == 'output' && value) {
            output = value;
        }
        else if (arg == 'seed' && value) {
            seed = value;
        }
        else if (arg == 'count' && value) {
            count = Number(value);
        }
        else if (arg == 'force') {
            force = true;
            disableAsserts();
            if (value != null)
                args.unshift(value);
        }
        else if (arg == 'help') {
            usage(0);
        }
        else if (arg == 'version' || arg == '-v') {
            console.log(version.VERSION);
            process.exit(0);
        }
        else if (arg == 'list-presets') {
            for (const { name } of Preset.all()) {
                console.log(name.replace(/ /g, ''));
            }
            process.exit(0);
        }
        else {
            console.error(`Bad argument: ${arg}`);
            usage(1);
        }
    }
    if (args.length != 1)
        usage(1);
    if (count > 1) {
        if (seed)
            fail('Cannot specify both --count and --seed');
        if (!/%[sc]/.test(output)) {
            fail('--output must have a %c or %s placeholder when --count is given');
        }
    }
    const flagset = new FlagSet(flags);
    const rom = new Uint8Array(fs.readFileSync(args[0]).buffer);
    if (crc32(rom) != EXPECTED_CRC32) {
        console.error(`WARNING: Bad CRC for input rom: ${crc32(rom).toString(16)}`);
        if (!force)
            fail('Run with --force to proceed anyway');
        console.error('Proceeding anyway');
    }
    return Promise.all(new Array(count).fill(0).map(async () => {
        const s = patch.parseSeed(seed);
        console.log(`Seed: ${s.toString(16)}`);
        const orig = rom.slice();
        const [shuffled, c] = await patch.shuffle(orig, s, flagset, new NodeReader());
        const n = args[0].replace('.nes', '');
        const f = String(flagset).replace(/ /g, '');
        const v = version.VERSION;
        const filename = fillTemplate(output, { c, n, s, v, f, '%': '%' }) + '.nes';
        await new Promise((resolve, reject) => fs.writeFile(filename, shuffled, (err) => err ? reject(err) : resolve()));
        console.log(`Wrote ${filename}`);
    }));
};
function fail(message) {
    console.error(message);
    throw process.exit(2);
}
function fillTemplate(str, arg) {
    const terms = [];
    while (str) {
        const index = str.indexOf('%');
        if (index < 0) {
            terms.push(str);
            str = '';
        }
        else {
            terms.push(str.substring(0, index));
            const ch = str[index + 1];
            if (!(ch in arg))
                throw new Error(`Bad placeholder: %${ch}`);
            terms.push(arg[ch]);
            str = str.substring(index + 2);
        }
    }
    return terms.join('');
}
process.on('unhandledRejection', (error) => {
    console.error(typeof error === 'string' ?
        error :
        error instanceof UsageError ? error.message : error.stack);
    process.exit(1);
});
const asyncMain = async () => {
    try {
        await main(...process.argv.slice(2));
    }
    catch (error) {
        if (error instanceof UsageError) {
            console.error(error.message);
            console.error(`Try passing --help for documentation.`);
            process.exit(1);
        }
        throw error;
    }
};
asyncMain().then(() => process.exit(0));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xpLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2pzL2NsaS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBRUEsT0FBTyxpQkFBaUIsQ0FBQztBQUV6QixPQUFPLEVBQUMsY0FBYyxFQUFDLE1BQU0sVUFBVSxDQUFDO0FBQ3hDLE9BQU8sRUFBQyxPQUFPLEVBQUUsTUFBTSxFQUFDLE1BQU0sY0FBYyxDQUFDO0FBQzdDLE9BQU8sRUFBQyxLQUFLLEVBQUMsTUFBTSxZQUFZLENBQUM7QUFDakMsT0FBTyxLQUFLLEVBQUUsTUFBTSxJQUFJLENBQUM7QUFDekIsT0FBTyxLQUFLLEtBQUssTUFBTSxZQUFZLENBQUM7QUFDcEMsT0FBTyxFQUFDLFVBQVUsRUFBRSxVQUFVLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFDakQsT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLGlCQUFpQixDQUFDO0FBQzNDLE9BQU8sS0FBSyxPQUFPLE1BQU0sY0FBYyxDQUFDO0FBQ3hDLE9BQU8sRUFBQyxjQUFjLEVBQUMsTUFBTSxhQUFhLENBQUM7QUFJM0MsTUFBTSxLQUFLLEdBQUcsQ0FBQyxJQUFZLEVBQUUsRUFBRTtJQUM3QixPQUFPLENBQUMsR0FBRyxDQUFDLHlCQUF5QixPQUFPLENBQUMsT0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBMkJwRCxNQUFNLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDN0MsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNyQixDQUFDLENBQUM7QUFFRixNQUFNLFVBQVUsR0FBRyxDQUFDLEVBQUMsV0FBVyxFQUFFLFVBQVUsRUFBRSxJQUFJLEVBQVMsRUFBRSxFQUFFO0lBQzdELE1BQU0sV0FBVyxHQUFHLEVBQUUsQ0FBQztJQUN2QixNQUFNLE9BQU8sR0FBRyxXQUFXLEdBQUcsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7SUFDOUMsTUFBTSxTQUFTLEdBQUcsVUFBVSxDQUFDLFVBQVUsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUNsRCxNQUFNLFVBQVUsR0FBRyxVQUFVLENBQUMsV0FBVyxFQUFFLFdBQVcsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUM1RCxNQUFNLE1BQU0sR0FBRyxJQUFJLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ2xELE9BQU8sS0FBSyxJQUFJLE1BQU0sU0FBUyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUM7SUFDMUMsVUFBVSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDO0FBQzlCLENBQUMsQ0FBQztBQUVGLE1BQU0sSUFBSSxHQUFHLENBQUMsR0FBRyxJQUFjLEVBQUUsRUFBRTtJQUNqQyxJQUFJLEtBQUssR0FBRyxXQUFXLENBQUM7SUFDeEIsSUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDO0lBQ2QsSUFBSSxJQUFJLEdBQUcsRUFBRSxDQUFDO0lBQ2QsSUFBSSxNQUFNLEdBQUcsT0FBTyxDQUFDO0lBQ3JCLElBQUksS0FBSyxHQUFHLEtBQUssQ0FBQztJQUNsQixPQUFPLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxFQUFFO1FBQzFDLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxLQUFLLEVBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDckMsSUFBSSxLQUFLLEdBQUcsU0FBUyxDQUFDO1FBQ3RCLE1BQU0sRUFBRSxHQUFHLEdBQUcsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDNUIsSUFBSSxFQUFFLElBQUksQ0FBQyxFQUFFO1lBQ1gsS0FBSyxHQUFHLEdBQUcsQ0FBQyxTQUFTLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQzlCLEdBQUcsR0FBRyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztTQUM1QjthQUFNO1lBQ0wsS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztTQUN0QjtRQUNELElBQUksR0FBRyxJQUFJLE9BQU8sSUFBSSxLQUFLLEVBQUU7WUFDM0IsS0FBSyxHQUFHLEtBQUssQ0FBQztTQUNmO2FBQU0sSUFBSSxHQUFHLElBQUksUUFBUSxJQUFJLEtBQUssRUFBRTtZQUNuQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1NBQ3ZDO2FBQU0sSUFBSSxHQUFHLElBQUksUUFBUSxJQUFJLEtBQUssRUFBRTtZQUNuQyxNQUFNLEdBQUcsS0FBSyxDQUFDO1NBQ2hCO2FBQU0sSUFBSSxHQUFHLElBQUksTUFBTSxJQUFJLEtBQUssRUFBRTtZQUNqQyxJQUFJLEdBQUcsS0FBSyxDQUFDO1NBQ2Q7YUFBTSxJQUFJLEdBQUcsSUFBSSxPQUFPLElBQUksS0FBSyxFQUFFO1lBQ2xDLEtBQUssR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDdkI7YUFBTSxJQUFJLEdBQUcsSUFBSSxPQUFPLEVBQUU7WUFDekIsS0FBSyxHQUFHLElBQUksQ0FBQztZQUNiLGNBQWMsRUFBRSxDQUFDO1lBQ2pCLElBQUksS0FBSyxJQUFJLElBQUk7Z0JBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUN4QzthQUFNLElBQUksR0FBRyxJQUFJLE1BQU0sRUFBRTtZQUN4QixLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDVjthQUFNLElBQUksR0FBRyxJQUFJLFNBQVMsSUFBSSxHQUFHLElBQUksSUFBSSxFQUFFO1lBQzFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQzdCLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDakI7YUFBTSxJQUFJLEdBQUcsSUFBSSxjQUFjLEVBQUU7WUFFaEMsS0FBSyxNQUFNLEVBQUMsSUFBSSxFQUFDLElBQUksTUFBTSxDQUFDLEdBQUcsRUFBRSxFQUFFO2dCQUNqQyxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7YUFDckM7WUFDRCxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ2pCO2FBQU07WUFDTCxPQUFPLENBQUMsS0FBSyxDQUFDLGlCQUFpQixHQUFHLEVBQUUsQ0FBQyxDQUFDO1lBQ3RDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNWO0tBQ0Y7SUFFRCxJQUFJLElBQUksQ0FBQyxNQUFNLElBQUksQ0FBQztRQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMvQixJQUFJLEtBQUssR0FBRyxDQUFDLEVBQUU7UUFDYixJQUFJLElBQUk7WUFBRSxJQUFJLENBQUMsd0NBQXdDLENBQUMsQ0FBQztRQUN6RCxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRTtZQUN6QixJQUFJLENBQUMsaUVBQWlFLENBQUMsQ0FBQztTQUN6RTtLQUNGO0lBRUQsTUFBTSxPQUFPLEdBQUcsSUFBSSxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDbkMsTUFBTSxHQUFHLEdBQUcsSUFBSSxVQUFVLENBQUMsRUFBRSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUM1RCxJQUFJLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxjQUFjLEVBQUU7UUFDaEMsT0FBTyxDQUFDLEtBQUssQ0FBQyxtQ0FBbUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDNUUsSUFBSSxDQUFDLEtBQUs7WUFBRSxJQUFJLENBQUMsb0NBQW9DLENBQUMsQ0FBQztRQUN2RCxPQUFPLENBQUMsS0FBSyxDQUFDLG1CQUFtQixDQUFDLENBQUM7S0FDcEM7SUFFRCxPQUFPLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLElBQUksRUFBRTtRQUN6RCxNQUFNLENBQUMsR0FBRyxLQUFLLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2hDLE9BQU8sQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUN2QyxNQUFNLElBQUksR0FBRyxHQUFHLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDekIsTUFBTSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUMsR0FDZixNQUFNLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxPQUFPLEVBQUUsSUFBSSxVQUFVLEVBQUUsQ0FBQyxDQUFDO1FBQzVELE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQ3RDLE1BQU0sQ0FBQyxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQzVDLE1BQU0sQ0FBQyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUM7UUFDMUIsTUFBTSxRQUFRLEdBQUcsWUFBWSxDQUFDLE1BQU0sRUFBRSxFQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBQyxDQUFDLEdBQUcsTUFBTSxDQUFDO1FBQzFFLE1BQU0sSUFBSSxPQUFPLENBQ2IsQ0FBQyxPQUFPLEVBQUUsTUFBTSxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUM3QixRQUFRLEVBQUUsUUFBUSxFQUFFLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ3JFLE9BQU8sQ0FBQyxHQUFHLENBQUMsU0FBUyxRQUFRLEVBQUUsQ0FBQyxDQUFDO0lBQ25DLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDTixDQUFDLENBQUM7QUFFRixTQUFTLElBQUksQ0FBQyxPQUFlO0lBQzNCLE9BQU8sQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDdkIsTUFBTSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3hCLENBQUM7QUFFRCxTQUFTLFlBQVksQ0FBQyxHQUFXLEVBQUUsR0FBNkI7SUFDOUQsTUFBTSxLQUFLLEdBQUcsRUFBRSxDQUFDO0lBQ2pCLE9BQU8sR0FBRyxFQUFFO1FBQ1YsTUFBTSxLQUFLLEdBQUcsR0FBRyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUMvQixJQUFJLEtBQUssR0FBRyxDQUFDLEVBQUU7WUFDYixLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ2hCLEdBQUcsR0FBRyxFQUFFLENBQUM7U0FDVjthQUFNO1lBQ0wsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDO1lBQ3BDLE1BQU0sRUFBRSxHQUFHLEdBQUcsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDMUIsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLEdBQUcsQ0FBQztnQkFBRSxNQUFNLElBQUksS0FBSyxDQUFDLHFCQUFxQixFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBQzdELEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDcEIsR0FBRyxHQUFHLEdBQUcsQ0FBQyxTQUFTLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDO1NBQ2hDO0tBQ0Y7SUFDRCxPQUFPLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDeEIsQ0FBQztBQUVELE9BQU8sQ0FBQyxFQUFFLENBQUMsb0JBQW9CLEVBQUUsQ0FBQyxLQUFVLEVBQUUsRUFBRTtJQUM5QyxPQUFPLENBQUMsS0FBSyxDQUNULE9BQU8sS0FBSyxLQUFLLFFBQVEsQ0FBQyxDQUFDO1FBQ3ZCLEtBQUssQ0FBQyxDQUFDO1FBQ1AsS0FBSyxZQUFZLFVBQVUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ25FLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDbEIsQ0FBQyxDQUFDLENBQUM7QUFFSCxNQUFNLFNBQVMsR0FDWCxLQUFLLElBQUksRUFBRTtJQUNiLElBQUk7UUFDRixNQUFNLElBQUksQ0FBQyxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDdEM7SUFBQyxPQUFPLEtBQUssRUFBRTtRQUNkLElBQUksS0FBSyxZQUFZLFVBQVUsRUFBRTtZQUMvQixPQUFPLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUM3QixPQUFPLENBQUMsS0FBSyxDQUFDLHVDQUF1QyxDQUFDLENBQUM7WUFDdkQsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNqQjtRQUNELE1BQU0sS0FBSyxDQUFDO0tBQ2I7QUFDSCxDQUFDLENBQUE7QUFFRCxTQUFTLEVBQUUsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiIyEvdXNyL2Jpbi9lbnYgLVMgbm9kZSAtciBlc20gLS1pbnNwZWN0IFxuXG5pbXBvcnQgJy4vYnVpbGRfaW5mby5qcyc7IC8vIHNpZGUgZWZmZWN0IGdsb2JhbCBzZXQgKGFmZmVjdHMgdmVyc2lvbiBtb2R1bGUpXG5cbmltcG9ydCB7RVhQRUNURURfQ1JDMzJ9IGZyb20gJy4vcm9tLmpzJztcbmltcG9ydCB7RmxhZ1NldCwgUHJlc2V0fSBmcm9tICcuL2ZsYWdzZXQuanMnO1xuaW1wb3J0IHtjcmMzMn0gZnJvbSAnLi9jcmMzMi5qcyc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG5pbXBvcnQgKiBhcyBwYXRjaCBmcm9tICcuL3BhdGNoLmpzJztcbmltcG9ydCB7VXNhZ2VFcnJvciwgYnJlYWtMaW5lc30gZnJvbSAnLi91dGlsLmpzJztcbmltcG9ydCB7Tm9kZVJlYWRlcn0gZnJvbSAnLi9ub2RlcmVhZGVyLmpzJztcbmltcG9ydCAqIGFzIHZlcnNpb24gZnJvbSAnLi92ZXJzaW9uLmpzJztcbmltcG9ydCB7ZGlzYWJsZUFzc2VydHN9IGZyb20gJy4vYXNzZXJ0LmpzJztcblxuLy8gVXNhZ2U6IG5vZGUgY2xpLmpzIFstLWZsYWdzPTxGTEFHUz5dIFstLXNlZWQ9PFNFRUQ+XSByb20ubmVzXG5cbmNvbnN0IHVzYWdlID0gKGNvZGU6IG51bWJlcikgPT4ge1xuICBjb25zb2xlLmxvZyhgQ3J5c3RhbGlzIFJhbmRvbWl6ZXIgdiR7dmVyc2lvbi5WRVJTSU9OfVxuVXNhZ2U6IGNyeXIgW09QVElPTlMuLi5dIHJvbS5uZXNcblxuT3B0aW9uc1xuICAtLWZsYWdzPUZMQUdTRVQgICAgU3BlY2lmeSB0aGUgZmxhZ3NldC5cbiAgLS1wcmVzZXQ9UFJFU0VUICAgIFNwZWNpZnkgdGhlIHByZXNldCBieSBuYW1lLlxuICAgICAgICAgICAgICAgICAgICAgU3BhY2VzIGFuZCBjYXBpdGFsaXphdGlvbiBhcmUgaWdub3JlZC5cbiAgLS1zZWVkPVNFRUQgICAgICAgIFNwZWNpZnkgdGhlIHNlZWQuXG4gIC0tb3V0cHV0PVBBVFRFUk4gICBTcGVjaWZ5IHRoZSBvdXRwdXQgZmlsZW5hbWUgcGF0dGVybi5cbiAgICAgICAgICAgICAgICAgICAgIE1heSBpbmNsdWRlIHBsYWNlaG9sZGVyczpcbiAgICAgICAgICAgICAgICAgICAgICAgJW46IGlucHV0IGJhc2UgZmlsZW5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgJXY6IGNyeXIgdmVyc2lvbiBoYXNoXG4gICAgICAgICAgICAgICAgICAgICAgICVzOiBzZWVkXG4gICAgICAgICAgICAgICAgICAgICAgICVmOiBmbGFnc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICVjOiBjaGVja3N1bVxuICAgICAgICAgICAgICAgICAgICAgVGhlIGRlZmF1bHQgcGF0dGVybiBpcyBcIiVuXyVjXCIuXG4gIC0tY291bnQ9TlVNQkVSICAgICBOdW1iZXIgb2Ygc2h1ZmZsZWQgcm9tcyB0byBnZW5lcmF0ZS5cbiAgICAgICAgICAgICAgICAgICAgIFRoaXMgZmxhZyBpcyBub3QgY29tcGF0aWJsZSB3aXRoIHNwZWNpZnlpbmdcbiAgICAgICAgICAgICAgICAgICAgIGEgc2VlZCBtYW51YWxseSwgbm9yIHdpdGggb3V0cHV0IHBhdHRlcm5zXG4gICAgICAgICAgICAgICAgICAgICB0aGF0IGRvbid0IGluY2x1ZGUgJXMgb3IgJWMuXG4gIC0tZm9yY2UgICAgICAgICAgICBEb24ndCBmYWlsIGR1ZSB0byB3cm9uZyBpbnB1dCBmaWxlIGNoZWNrc3VtLlxuXG5GbGFnc1xuICBUaGUgcmFuZG9taXplciBzdXBwb3J0cyBhIG51bWJlciBvZiBvcHRpb25zLCBkb2N1bWVudGVkIGluIGRldGFpbFxuICBhdCBodHRwczovL2NyeXN0YWxpc3JhbmRvbWl6ZXIuY29tLiAgU3BhY2VzIGFyZSBpZ25vcmVkLlxuXG5QcmVzZXRzXG4ke1ByZXNldC5hbGwoKS5tYXAoc2hvd1ByZXNldCkuam9pbignXFxuXFxuJyl9YCk7XG4gIHByb2Nlc3MuZXhpdChjb2RlKTtcbn07XG5cbmNvbnN0IHNob3dQcmVzZXQgPSAoe2Rlc2NyaXB0aW9uLCBmbGFnU3RyaW5nLCBuYW1lfTogUHJlc2V0KSA9PiB7XG4gIGNvbnN0IExJTkVfTEVOR1RIID0gNjg7XG4gIGNvbnN0IGZsYWdMZW4gPSBMSU5FX0xFTkdUSCAtIG5hbWUubGVuZ3RoIC0gNjtcbiAgY29uc3QgZmxhZ0xpbmVzID0gYnJlYWtMaW5lcyhmbGFnU3RyaW5nLCBmbGFnTGVuKTtcbiAgY29uc3QgZGVzY3JMaW5lcyA9IGJyZWFrTGluZXMoZGVzY3JpcHRpb24sIExJTkVfTEVOR1RIIC0gMik7XG4gIGNvbnN0IGluZGVudCA9ICdcXG4nICsgJyAnLnJlcGVhdChuYW1lLmxlbmd0aCArIDUpO1xuICByZXR1cm4gYCAgJHtuYW1lfTogXCIke2ZsYWdMaW5lcy5qb2luKGluZGVudCl9XCJcbiAgJHtkZXNjckxpbmVzLmpvaW4oJ1xcbiAgJyl9YDtcbn07XG5cbmNvbnN0IG1haW4gPSAoLi4uYXJnczogc3RyaW5nW10pID0+IHtcbiAgbGV0IGZsYWdzID0gJ0BTdGFuZGFyZCc7XG4gIGxldCBjb3VudCA9IDE7XG4gIGxldCBzZWVkID0gJyc7XG4gIGxldCBvdXRwdXQgPSAnJW5fJWMnO1xuICBsZXQgZm9yY2UgPSBmYWxzZTtcbiAgd2hpbGUgKGFyZ3NbMF0gJiYgYXJnc1swXS5zdGFydHNXaXRoKCctLScpKSB7XG4gICAgbGV0IGFyZyA9IGFyZ3Muc2hpZnQoKSEuc3Vic3RyaW5nKDIpO1xuICAgIGxldCB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICBjb25zdCBlcSA9IGFyZy5pbmRleE9mKCc9Jyk7XG4gICAgaWYgKGVxID49IDApIHtcbiAgICAgIHZhbHVlID0gYXJnLnN1YnN0cmluZyhlcSArIDEpO1xuICAgICAgYXJnID0gYXJnLnN1YnN0cmluZygwLCBlcSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gYXJncy5zaGlmdCgpO1xuICAgIH1cbiAgICBpZiAoYXJnID09ICdmbGFncycgJiYgdmFsdWUpIHtcbiAgICAgIGZsYWdzID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmIChhcmcgPT0gJ3ByZXNldCcgJiYgdmFsdWUpIHtcbiAgICAgIGZsYWdzID0gJ0AnICsgdmFsdWUucmVwbGFjZSgvIC9nLCAnJyk7XG4gICAgfSBlbHNlIGlmIChhcmcgPT0gJ291dHB1dCcgJiYgdmFsdWUpIHtcbiAgICAgIG91dHB1dCA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAoYXJnID09ICdzZWVkJyAmJiB2YWx1ZSkge1xuICAgICAgc2VlZCA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAoYXJnID09ICdjb3VudCcgJiYgdmFsdWUpIHtcbiAgICAgIGNvdW50ID0gTnVtYmVyKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGFyZyA9PSAnZm9yY2UnKSB7XG4gICAgICBmb3JjZSA9IHRydWU7XG4gICAgICBkaXNhYmxlQXNzZXJ0cygpO1xuICAgICAgaWYgKHZhbHVlICE9IG51bGwpIGFyZ3MudW5zaGlmdCh2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChhcmcgPT0gJ2hlbHAnKSB7XG4gICAgICB1c2FnZSgwKTtcbiAgICB9IGVsc2UgaWYgKGFyZyA9PSAndmVyc2lvbicgfHwgYXJnID09ICctdicpIHtcbiAgICAgIGNvbnNvbGUubG9nKHZlcnNpb24uVkVSU0lPTik7XG4gICAgICBwcm9jZXNzLmV4aXQoMCk7XG4gICAgfSBlbHNlIGlmIChhcmcgPT0gJ2xpc3QtcHJlc2V0cycpIHtcbiAgICAgIC8vIHVuZG9jdW1lbnRlZCBmbGFnXG4gICAgICBmb3IgKGNvbnN0IHtuYW1lfSBvZiBQcmVzZXQuYWxsKCkpIHtcbiAgICAgICAgY29uc29sZS5sb2cobmFtZS5yZXBsYWNlKC8gL2csICcnKSk7XG4gICAgICB9XG4gICAgICBwcm9jZXNzLmV4aXQoMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEJhZCBhcmd1bWVudDogJHthcmd9YCk7XG4gICAgICB1c2FnZSgxKTtcbiAgICB9XG4gIH1cblxuICBpZiAoYXJncy5sZW5ndGggIT0gMSkgdXNhZ2UoMSk7XG4gIGlmIChjb3VudCA+IDEpIHtcbiAgICBpZiAoc2VlZCkgZmFpbCgnQ2Fubm90IHNwZWNpZnkgYm90aCAtLWNvdW50IGFuZCAtLXNlZWQnKTtcbiAgICBpZiAoIS8lW3NjXS8udGVzdChvdXRwdXQpKSB7XG4gICAgICBmYWlsKCctLW91dHB1dCBtdXN0IGhhdmUgYSAlYyBvciAlcyBwbGFjZWhvbGRlciB3aGVuIC0tY291bnQgaXMgZ2l2ZW4nKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBmbGFnc2V0ID0gbmV3IEZsYWdTZXQoZmxhZ3MpO1xuICBjb25zdCByb20gPSBuZXcgVWludDhBcnJheShmcy5yZWFkRmlsZVN5bmMoYXJnc1swXSkuYnVmZmVyKTtcbiAgaWYgKGNyYzMyKHJvbSkgIT0gRVhQRUNURURfQ1JDMzIpIHtcbiAgICBjb25zb2xlLmVycm9yKGBXQVJOSU5HOiBCYWQgQ1JDIGZvciBpbnB1dCByb206ICR7Y3JjMzIocm9tKS50b1N0cmluZygxNil9YCk7XG4gICAgaWYgKCFmb3JjZSkgZmFpbCgnUnVuIHdpdGggLS1mb3JjZSB0byBwcm9jZWVkIGFueXdheScpO1xuICAgIGNvbnNvbGUuZXJyb3IoJ1Byb2NlZWRpbmcgYW55d2F5Jyk7XG4gIH1cblxuICByZXR1cm4gUHJvbWlzZS5hbGwobmV3IEFycmF5KGNvdW50KS5maWxsKDApLm1hcChhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgcyA9IHBhdGNoLnBhcnNlU2VlZChzZWVkKTtcbiAgICBjb25zb2xlLmxvZyhgU2VlZDogJHtzLnRvU3RyaW5nKDE2KX1gKTtcbiAgICBjb25zdCBvcmlnID0gcm9tLnNsaWNlKCk7XG4gICAgY29uc3QgW3NodWZmbGVkLCBjXSA9XG4gICAgICAgIGF3YWl0IHBhdGNoLnNodWZmbGUob3JpZywgcywgZmxhZ3NldCwgbmV3IE5vZGVSZWFkZXIoKSk7XG4gICAgY29uc3QgbiA9IGFyZ3NbMF0ucmVwbGFjZSgnLm5lcycsICcnKTtcbiAgICBjb25zdCBmID0gU3RyaW5nKGZsYWdzZXQpLnJlcGxhY2UoLyAvZywgJycpO1xuICAgIGNvbnN0IHYgPSB2ZXJzaW9uLlZFUlNJT047XG4gICAgY29uc3QgZmlsZW5hbWUgPSBmaWxsVGVtcGxhdGUob3V0cHV0LCB7YywgbiwgcywgdiwgZiwgJyUnOiAnJSd9KSArICcubmVzJztcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShcbiAgICAgICAgKHJlc29sdmUsIHJlamVjdCkgPT4gZnMud3JpdGVGaWxlKFxuICAgICAgICAgICAgZmlsZW5hbWUsIHNodWZmbGVkLCAoZXJyKSA9PiBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUoKSkpO1xuICAgIGNvbnNvbGUubG9nKGBXcm90ZSAke2ZpbGVuYW1lfWApO1xuICB9KSk7XG59O1xuXG5mdW5jdGlvbiBmYWlsKG1lc3NhZ2U6IHN0cmluZyk6IG5ldmVyIHtcbiAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgdGhyb3cgcHJvY2Vzcy5leGl0KDIpO1xufVxuXG5mdW5jdGlvbiBmaWxsVGVtcGxhdGUoc3RyOiBzdHJpbmcsIGFyZzoge1trZXk6IHN0cmluZ106IHVua25vd259KTogc3RyaW5nIHtcbiAgY29uc3QgdGVybXMgPSBbXTtcbiAgd2hpbGUgKHN0cikge1xuICAgIGNvbnN0IGluZGV4ID0gc3RyLmluZGV4T2YoJyUnKTtcbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICB0ZXJtcy5wdXNoKHN0cik7XG4gICAgICBzdHIgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgdGVybXMucHVzaChzdHIuc3Vic3RyaW5nKDAsIGluZGV4KSk7XG4gICAgICBjb25zdCBjaCA9IHN0cltpbmRleCArIDFdO1xuICAgICAgaWYgKCEoY2ggaW4gYXJnKSkgdGhyb3cgbmV3IEVycm9yKGBCYWQgcGxhY2Vob2xkZXI6ICUke2NofWApO1xuICAgICAgdGVybXMucHVzaChhcmdbY2hdKTtcbiAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoaW5kZXggKyAyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRlcm1zLmpvaW4oJycpO1xufVxuXG5wcm9jZXNzLm9uKCd1bmhhbmRsZWRSZWplY3Rpb24nLCAoZXJyb3I6IGFueSkgPT4ge1xuICBjb25zb2xlLmVycm9yKFxuICAgICAgdHlwZW9mIGVycm9yID09PSAnc3RyaW5nJyA/XG4gICAgICAgICAgZXJyb3IgOlxuICAgICAgICAgIGVycm9yIGluc3RhbmNlb2YgVXNhZ2VFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBlcnJvci5zdGFjayk7XG4gIHByb2Nlc3MuZXhpdCgxKTtcbn0pO1xuXG5jb25zdCBhc3luY01haW4gPVxuICAgIGFzeW5jICgpID0+IHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBtYWluKC4uLnByb2Nlc3MuYXJndi5zbGljZSgyKSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgVXNhZ2VFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFRyeSBwYXNzaW5nIC0taGVscCBmb3IgZG9jdW1lbnRhdGlvbi5gKTtcbiAgICAgIHByb2Nlc3MuZXhpdCgxKTtcbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuYXN5bmNNYWluKCkudGhlbigoKSA9PiBwcm9jZXNzLmV4aXQoMCkpO1xuIl19