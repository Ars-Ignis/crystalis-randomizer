import { assertNever } from '../util.js';
export var TokenSource;
(function (TokenSource) {
    class Abstract {
        next() {
            while (true) {
                if (!this.sink)
                    this.sink = this.pump();
                const { value, done } = this.sink.next();
                if (!done)
                    return value;
                this.sink = undefined;
            }
        }
    }
    TokenSource.Abstract = Abstract;
    function concat(...sources) {
        let source;
        return {
            next: () => {
                while (true) {
                    if (!source)
                        source = sources.shift();
                    if (!source)
                        return undefined;
                    const line = source.next();
                    if (line)
                        return line;
                    source = undefined;
                }
            },
        };
    }
    TokenSource.concat = concat;
})(TokenSource || (TokenSource = {}));
export var Token;
(function (Token) {
    Token.LB = { token: 'lb' };
    Token.LC = { token: 'lc' };
    Token.LP = { token: 'lp' };
    Token.RB = { token: 'rb' };
    Token.RC = { token: 'rc' };
    Token.RP = { token: 'rp' };
    Token.EOL = { token: 'eol' };
    Token.EOF = { token: 'eof' };
    Token.DEFINE = { token: 'cs', str: '.define' };
    Token.DOT_EOL = { token: 'cs', str: '.eol' };
    Token.ELSE = { token: 'cs', str: '.else' };
    Token.ELSEIF = { token: 'cs', str: '.elseif' };
    Token.ENDIF = { token: 'cs', str: '.endif' };
    Token.ENDMAC = { token: 'cs', str: '.endmac' };
    Token.ENDMACRO = { token: 'cs', str: '.endmacro' };
    Token.ENDREP = { token: 'cs', str: '.endrep' };
    Token.ENDREPEAT = { token: 'cs', str: '.endrepeat' };
    Token.ENDPROC = { token: 'cs', str: '.endproc' };
    Token.ENDSCOPE = { token: 'cs', str: '.endscope' };
    Token.LOCAL = { token: 'cs', str: '.local' };
    Token.MACRO = { token: 'cs', str: '.macro' };
    Token.REPEAT = { token: 'cs', str: '.repeat' };
    Token.SET = { token: 'cs', str: '.set' };
    Token.SKIP = { token: 'cs', str: '.skip' };
    Token.BYTE = { token: 'cs', str: '.byte' };
    Token.WORD = { token: 'cs', str: '.word' };
    Token.COLON = { token: 'op', str: ':' };
    Token.COMMA = { token: 'op', str: ',' };
    Token.STAR = { token: 'op', str: '*' };
    Token.IMMEDIATE = { token: 'op', str: '#' };
    Token.ASSIGN = { token: 'op', str: '=' };
    function match(left, right) {
        if (left.token !== right.token)
            return false;
        if (left.token === 'num' || left.token === 'str')
            return true;
        if (left.str !== right.str)
            return false;
        return true;
    }
    Token.match = match;
    function eq(left, right) {
        if (!left || !right)
            return false;
        if (left.token !== right.token)
            return false;
        if (left.token === 'grp')
            return false;
        if (left.str !== right.str)
            return false;
        if (left.num !== right.num)
            return false;
        return true;
    }
    Token.eq = eq;
    function name(arg) {
        switch (arg.token) {
            case 'num': return `NUM[$${arg.num.toString(16)}]`;
            case 'str': return `STR[$${arg.str}]`;
            case 'lb': return `[`;
            case 'rb': return `]`;
            case 'grp': return `{`;
            case 'lc': return `{`;
            case 'rc': return `}`;
            case 'lp': return `(`;
            case 'rp': return `)`;
            case 'eol': return `EOL`;
            case 'eof': return `EOF`;
            case 'ident':
                return arg.str;
            case 'cs':
            case 'op':
                return `${arg.str.toUpperCase()}`;
            default:
                assertNever(arg);
        }
    }
    Token.name = name;
    function at(arg) {
        const s = arg.source;
        if (!s)
            return '';
        const parent = s.parent ? at({ source: s.parent }) : '';
        return `\n  at ${s.file}:${s.line}:${s.column}${parent}`;
    }
    Token.at = at;
    function nameAt(arg) {
        return name(arg) + at(arg);
    }
    Token.nameAt = nameAt;
    function expectEol(token, name = 'end of line') {
        if (token)
            throw new Error(`Expected ${name}: ${Token.nameAt(token)}`);
    }
    Token.expectEol = expectEol;
    function expect(want, token, prev) {
        if (!token) {
            if (!prev)
                throw new Error(`Expected ${name(want)}`);
            throw new Error(`Expected ${name(want)} after ${nameAt(token)}`);
        }
        if (!eq(want, token)) {
            throw new Error(`Expected ${name(want)}: ${nameAt(token)}`);
        }
    }
    Token.expect = expect;
    function expectIdentifier(token, prev) {
        return expectStringToken('ident', 'identifier', token, prev);
    }
    Token.expectIdentifier = expectIdentifier;
    function expectString(token, prev) {
        return expectStringToken('str', 'constant string', token, prev);
    }
    Token.expectString = expectString;
    function expectStringToken(want, name, token, prev) {
        if (!token) {
            if (!prev)
                throw new Error(`Expected ${name}`);
            throw new Error(`Expected ${name} after ${nameAt(prev)}`);
        }
        if (token.token !== want) {
            throw new Error(`Expected ${name}: ${nameAt(token)}`);
        }
        return token.str;
    }
    function identsFromCList(list) {
        var _a;
        if (!list.length)
            return [];
        const out = [];
        for (let i = 0; i <= list.length; i += 2) {
            const ident = list[i];
            if (((_a = ident) === null || _a === void 0 ? void 0 : _a.token) !== 'ident') {
                if (ident)
                    throw new Error(`Expected identifier: ${nameAt(ident)}`);
                const last = list[list.length - 1];
                throw new Error(`Expected identifier after ${nameAt(last)}`);
            }
            else if (i + 1 < list.length && !eq(list[i + 1], Token.COMMA)) {
                const sep = list[i + 1];
                throw new Error(`Expected comma: ${nameAt(sep)}`);
            }
            out.push(ident.str);
        }
        return out;
    }
    Token.identsFromCList = identsFromCList;
    function findBalanced(tokens, i) {
        const open = tokens[i++].token;
        if (open !== 'lp' && open !== 'lb')
            throw new Error(`non-grouping token`);
        const close = open === 'lp' ? 'rp' : 'rb';
        let depth = 1;
        for (; i < tokens.length; i++) {
            const tok = tokens[i].token;
            depth += Number(tok === open) - Number(tok === close);
            if (!depth)
                return i;
        }
        return -1;
    }
    Token.findBalanced = findBalanced;
    function parseArgList(tokens, start = 0, end = tokens.length) {
        let arg = [];
        const args = [arg];
        let parens = 0;
        for (let i = start; i < end; i++) {
            const token = tokens[i];
            if (!parens && eq(token, Token.COMMA)) {
                args.push(arg = []);
            }
            else {
                arg.push(token);
                if (eq(token, Token.LP))
                    parens++;
                if (eq(token, Token.RP)) {
                    if (--parens < 0)
                        throw new Error(`Unbalanced paren${at(token)}`);
                }
            }
        }
        return args;
    }
    Token.parseArgList = parseArgList;
    function parseAttrList(tokens, start) {
        const out = new Map();
        let key;
        let val = [];
        if (start >= tokens.length)
            return out;
        if (!eq(tokens[start], Token.COLON)) {
            throw new Error(`Unexpected: ${nameAt(tokens[start])}`);
        }
        for (let i = start + 1; i < tokens.length; i++) {
            const tok = tokens[i];
            if (eq(tok, Token.COLON)) {
                if (key == null)
                    throw new Error(`Missing key${at(tok)}`);
                out.set(key, val);
                key = undefined;
                val = [];
            }
            else if (key == null) {
                key = expectIdentifier(tok);
            }
            else {
                val.push(tok);
            }
        }
        if (key != null) {
            out.set(key, val);
        }
        else {
            expectIdentifier(undefined, tokens[tokens.length - 1]);
        }
        return out;
    }
    Token.parseAttrList = parseAttrList;
    function findComma(tokens, start) {
        const index = find(tokens, Token.COMMA, start);
        return index < 0 ? tokens.length : index;
    }
    Token.findComma = findComma;
    function find(tokens, want, start) {
        for (let i = start; i < tokens.length; i++) {
            if (eq(tokens[i], want))
                return i;
        }
        return -1;
    }
    Token.find = find;
    function count(ts) {
        let total = 0;
        for (const t of ts) {
            if (t.token === 'grp') {
                total += 2 + count(t.inner);
            }
            else {
                total++;
            }
        }
        return total;
    }
    Token.count = count;
    function isRegister(t, reg) {
        return t.token === 'ident' && t.str.toLowerCase() === reg;
    }
    Token.isRegister = isRegister;
    function str(t) {
        switch (t.token) {
            case 'cs':
            case 'ident':
            case 'str':
            case 'op':
                return t.str;
        }
        throw new Error(`Non-string token: ${Token.nameAt(t)}`);
    }
    Token.str = str;
    function strip(t) {
        delete t.source;
        return t;
    }
    Token.strip = strip;
})(Token || (Token = {}));
export const TOKENFUNCS = new Set([
    '.blank',
    '.const',
    '.defined',
    '.left',
    '.match',
    '.mid',
    '.right',
    '.tcount',
    '.xmatch',
]);
export const DIRECTIVES = [
    '.define',
    '.else',
    '.elseif',
    '.endif',
    '.endmacro',
    '.endproc',
    '.endscope',
    '.ident',
    '.if',
    '.ifblank',
    '.ifdef',
    '.ifnblank',
    '.ifndef',
    '.ifnref',
    '.ifref',
    '.include',
    '.local',
    '.macro',
    '.proc',
    '.scope',
    '.skip',
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9rZW4uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvanMvYXNtL3Rva2VuLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBQyxXQUFXLEVBQUMsTUFBTSxZQUFZLENBQUM7QUFNdkMsTUFBTSxLQUFXLFdBQVcsQ0F3QzNCO0FBeENELFdBQWlCLFdBQVc7SUFNMUIsTUFBc0IsUUFBUTtRQVU1QixJQUFJO1lBQ0YsT0FBTyxJQUFJLEVBQUU7Z0JBQ1gsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJO29CQUFFLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO2dCQUN4QyxNQUFNLEVBQUMsS0FBSyxFQUFFLElBQUksRUFBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7Z0JBQ3ZDLElBQUksQ0FBQyxJQUFJO29CQUFFLE9BQU8sS0FBSyxDQUFDO2dCQUN4QixJQUFJLENBQUMsSUFBSSxHQUFHLFNBQVMsQ0FBQzthQUN2QjtRQUNILENBQUM7S0FDRjtJQWxCcUIsb0JBQVEsV0FrQjdCLENBQUE7SUFFRCxTQUFnQixNQUFNLENBQUMsR0FBRyxPQUFzQjtRQUM5QyxJQUFJLE1BQTZCLENBQUM7UUFDbEMsT0FBTztZQUNMLElBQUksRUFBRSxHQUFzQixFQUFFO2dCQUM1QixPQUFPLElBQUksRUFBRTtvQkFDWCxJQUFJLENBQUMsTUFBTTt3QkFBRSxNQUFNLEdBQUcsT0FBTyxDQUFDLEtBQUssRUFBRSxDQUFDO29CQUN0QyxJQUFJLENBQUMsTUFBTTt3QkFBRSxPQUFPLFNBQVMsQ0FBQztvQkFDOUIsTUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLElBQUksRUFBRSxDQUFDO29CQUMzQixJQUFJLElBQUk7d0JBQUUsT0FBTyxJQUFJLENBQUM7b0JBQ3RCLE1BQU0sR0FBRyxTQUFTLENBQUM7aUJBQ3BCO1lBQ0gsQ0FBQztTQUNGLENBQUM7SUFDSixDQUFDO0lBYmUsa0JBQU0sU0FhckIsQ0FBQTtBQUNILENBQUMsRUF4Q2dCLFdBQVcsS0FBWCxXQUFXLFFBd0MzQjtBQXVDRCxNQUFNLEtBQVcsS0FBSyxDQWtSckI7QUFsUkQsV0FBaUIsS0FBSztJQUVQLFFBQUUsR0FBVSxFQUFDLEtBQUssRUFBRSxJQUFJLEVBQUMsQ0FBQztJQUMxQixRQUFFLEdBQVUsRUFBQyxLQUFLLEVBQUUsSUFBSSxFQUFDLENBQUM7SUFDMUIsUUFBRSxHQUFVLEVBQUMsS0FBSyxFQUFFLElBQUksRUFBQyxDQUFDO0lBQzFCLFFBQUUsR0FBVSxFQUFDLEtBQUssRUFBRSxJQUFJLEVBQUMsQ0FBQztJQUMxQixRQUFFLEdBQVUsRUFBQyxLQUFLLEVBQUUsSUFBSSxFQUFDLENBQUM7SUFDMUIsUUFBRSxHQUFVLEVBQUMsS0FBSyxFQUFFLElBQUksRUFBQyxDQUFDO0lBQzFCLFNBQUcsR0FBVSxFQUFDLEtBQUssRUFBRSxLQUFLLEVBQUMsQ0FBQztJQUM1QixTQUFHLEdBQVUsRUFBQyxLQUFLLEVBQUUsS0FBSyxFQUFDLENBQUM7SUFFNUIsWUFBTSxHQUFVLEVBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFDLENBQUM7SUFDOUMsYUFBTyxHQUFVLEVBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFDLENBQUM7SUFDNUMsVUFBSSxHQUFVLEVBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsT0FBTyxFQUFDLENBQUM7SUFDMUMsWUFBTSxHQUFVLEVBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFDLENBQUM7SUFDOUMsV0FBSyxHQUFVLEVBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFDLENBQUM7SUFDNUMsWUFBTSxHQUFVLEVBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFDLENBQUM7SUFDOUMsY0FBUSxHQUFVLEVBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsV0FBVyxFQUFDLENBQUM7SUFDbEQsWUFBTSxHQUFVLEVBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFDLENBQUM7SUFDOUMsZUFBUyxHQUFVLEVBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsWUFBWSxFQUFDLENBQUM7SUFDcEQsYUFBTyxHQUFVLEVBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsVUFBVSxFQUFDLENBQUM7SUFDaEQsY0FBUSxHQUFVLEVBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsV0FBVyxFQUFDLENBQUM7SUFDbEQsV0FBSyxHQUFVLEVBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFDLENBQUM7SUFDNUMsV0FBSyxHQUFVLEVBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFDLENBQUM7SUFDNUMsWUFBTSxHQUFVLEVBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFDLENBQUM7SUFDOUMsU0FBRyxHQUFVLEVBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFDLENBQUM7SUFDeEMsVUFBSSxHQUFVLEVBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsT0FBTyxFQUFDLENBQUM7SUFHMUMsVUFBSSxHQUFVLEVBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsT0FBTyxFQUFDLENBQUM7SUFDMUMsVUFBSSxHQUFVLEVBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsT0FBTyxFQUFDLENBQUM7SUFHMUMsV0FBSyxHQUFVLEVBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFDLENBQUM7SUFFdkMsV0FBSyxHQUFVLEVBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFDLENBQUM7SUFDdkMsVUFB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QUhlLFdBQUssUUFHcEIsQ0FBQTtBQUNILENBQUMsRUFsUmdCLEtBQUssS0FBTCxLQUFLLFFBa1JyQjtBQWFELE1BQU0sQ0FBQyxNQUFNLFVBQVUsR0FBRyxJQUFJLEdBQUcsQ0FBQztJQUNoQyxRQUFRO0lBQ1IsUUFBUTtJQUNSLFVBQVU7SUFDVixPQUFPO0lBQ1AsUUFBUTtJQUNSLE1BQU07SUFDTixRQUFRO0lBQ1IsU0FBUztJQUNULFNBQVM7Q0FDVixDQUFDLENBQUM7QUFFSCxNQUFNLENBQUMsTUFBTSxVQUFVLEdBQUc7SUFDeEIsU0FBUztJQUNULE9BQU87SUFDUCxTQUFTO0lBQ1QsUUFBUTtJQUNSLFdBQVc7SUFDWCxVQUFVO0lBQ1YsV0FBVztJQUNYLFFBQVE7SUFDUixLQUFLO0lBQ0wsVUFBVTtJQUNWLFFBQVE7SUFDUixXQUFXO0lBQ1gsU0FBUztJQUNULFNBQVM7SUFDVCxRQUFRO0lBQ1IsVUFBVTtJQUNWLFFBQVE7SUFDUixRQUFRO0lBQ1IsT0FBTztJQUNQLFFBQVE7SUFDUixPQUFPO0NBQ0MsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7YXNzZXJ0TmV2ZXJ9IGZyb20gJy4uL3V0aWwuanMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRva2VuU291cmNlIHtcbiAgbmV4dCgpOiBUb2tlbltdfHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBUb2tlblNvdXJjZSB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgQXN5bmMge1xuICAgIG5leHRBc3luYygpOiBQcm9taXNlPFRva2VuW118dW5kZWZpbmVkPjtcbiAgfVxuXG4gIC8vIFRPRE8gLSBjb25zaWRlciBtb3ZpbmcgaW50byBhIG5hbWVzcGFjZT9cbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIEFic3RyYWN0IGltcGxlbWVudHMgVG9rZW5Tb3VyY2Uge1xuICAgIC8vIFRPRE8gLSBtb3ZlIHB1bXAoKSBpbnRvIGhlcmUsIHJlZmFjdG9yIFByZXByb2Nlc3NvciBhcyBhIFRva2VuU291cmNlXG4gICAgLy8gVE9ETyAtIHJlbmFtZSBQcm9jZXNzb3IgaW50byBBc3NlbWJsZXIsIGZpeCB1cCB0aGUgY2x1bmt5IG1ldGhvZHNcbiAgICAvLyAgICAgIC0gYWRkIGxpbmUoVG9rZW5bXSksIHRva2VucyhUb2tlblNvdXJjZSkgYW5kIGFzeW5jVG9rZW5zKEFUUylcbiAgICAvLyAgICAgICAgdGhlIGxhdHRlciByZXR1cm5zIFByb21pc2U8dm9pZD4gYW5kIG11c3QgYmUgYXdhaXRlZC5cbiAgICAvLyBEZWxlZ2F0ZSB0aGUgXG4gICAgcHJpdmF0ZSBzaW5rOiBJdGVyYXRvcjxUb2tlbltdfHVuZGVmaW5lZD58dW5kZWZpbmVkO1xuXG4gICAgYWJzdHJhY3QgcHVtcCgpOiBHZW5lcmF0b3I8VG9rZW5bXXx1bmRlZmluZWQ+O1xuXG4gICAgbmV4dCgpOiBUb2tlbltdfHVuZGVmaW5lZCB7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuc2luaykgdGhpcy5zaW5rID0gdGhpcy5wdW1wKCk7XG4gICAgICAgIGNvbnN0IHt2YWx1ZSwgZG9uZX0gPSB0aGlzLnNpbmsubmV4dCgpO1xuICAgICAgICBpZiAoIWRvbmUpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgdGhpcy5zaW5rID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGV4cG9ydCBmdW5jdGlvbiBjb25jYXQoLi4uc291cmNlczogVG9rZW5Tb3VyY2VbXSk6IFRva2VuU291cmNlIHtcbiAgICBsZXQgc291cmNlOiBUb2tlblNvdXJjZXx1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQ6ICgpOiBUb2tlbltdfHVuZGVmaW5lZCA9PiB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgaWYgKCFzb3VyY2UpIHNvdXJjZSA9IHNvdXJjZXMuc2hpZnQoKTtcbiAgICAgICAgICBpZiAoIXNvdXJjZSkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICBjb25zdCBsaW5lID0gc291cmNlLm5leHQoKTtcbiAgICAgICAgICBpZiAobGluZSkgcmV0dXJuIGxpbmU7XG4gICAgICAgICAgc291cmNlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBTb3VyY2VJbmZvIHtcbiAgZmlsZTogc3RyaW5nO1xuICBsaW5lOiBudW1iZXI7XG4gIGNvbHVtbjogbnVtYmVyO1xuICBwYXJlbnQ/OiBTb3VyY2VJbmZvOyAvLyBtYWNyby1leHBhbnNpb24gc3RhY2suLi5cbn1cblxuZXhwb3J0IHR5cGUgR3JvdXBUb2sgPSAnZ3JwJztcbmV4cG9ydCB0eXBlIFN0cmluZ1RvayA9ICdpZGVudCcgfCAnb3AnIHwgJ2NzJyB8ICdzdHInO1xuZXhwb3J0IHR5cGUgTnVtYmVyVG9rID0gJ251bSc7XG5leHBvcnQgdHlwZSBOdWxsVG9rID0gJ2xiJyB8ICdsYycgfCAnbHAnIHwgJ3JiJyB8ICdyYycgfCAncnAnIHwgJ2VvbCcgfCAnZW9mJztcblxuLy8gTk9URTogVGhpcyBpcyBub3QgdG9rZW5pemVkIGluaXRpYWxseSwgYnV0IGlzIGFkZGVkICp2ZXJ5KiBlYXJseSBmb3Jcbi8vIGN1cmx5LWJyYWNlIGdyb3VwcyBzaW5jZSBiYXNpY2FsbHkgZXZlcnl0aGluZyB3YW50cyB0byBza2lwIG92ZXIgdGhlbVxuLy8gaW4gYSBzaW5nbGUgZ28uICBXZSBkb24ndCB0cmVhdCBhbnkgb3RoZXIgZ3JvdXBpbmcgb3BlcmF0b3JzIGFzIHN0cm9uZ2x5LlxuZXhwb3J0IGludGVyZmFjZSBHcm91cFRva2VuIHtcbiAgdG9rZW46IEdyb3VwVG9rO1xuICBpbm5lcjogVG9rZW5bXTtcbiAgc291cmNlPzogU291cmNlSW5mbztcbn1cbmV4cG9ydCBpbnRlcmZhY2UgU3RyaW5nVG9rZW4ge1xuICB0b2tlbjogU3RyaW5nVG9rO1xuICBzdHI6IHN0cmluZztcbiAgc291cmNlPzogU291cmNlSW5mbztcbn1cbmV4cG9ydCBpbnRlcmZhY2UgTnVtYmVyVG9rZW4ge1xuICB0b2tlbjogTnVtYmVyVG9rO1xuICBudW06IG51bWJlcjtcbiAgc291cmNlPzogU291cmNlSW5mbztcbn1cbmV4cG9ydCBpbnRlcmZhY2UgTnVsbGFyeVRva2VuIHtcbiAgdG9rZW46IE51bGxUb2s7XG4gIHNvdXJjZT86IFNvdXJjZUluZm87XG59XG5cbmV4cG9ydCB0eXBlIFRva2VuID0gR3JvdXBUb2tlbiB8IFN0cmluZ1Rva2VuIHwgTnVtYmVyVG9rZW4gfCBOdWxsYXJ5VG9rZW47XG5cbmV4cG9ydCBuYW1lc3BhY2UgVG9rZW4ge1xuICAvLyBHcm91cGluZyB0b2tlbnNcbiAgZXhwb3J0IGNvbnN0IExCOiBUb2tlbiA9IHt0b2tlbjogJ2xiJ307XG4gIGV4cG9ydCBjb25zdCBMQzogVG9rZW4gPSB7dG9rZW46ICdsYyd9O1xuICBleHBvcnQgY29uc3QgTFA6IFRva2VuID0ge3Rva2VuOiAnbHAnfTtcbiAgZXhwb3J0IGNvbnN0IFJCOiBUb2tlbiA9IHt0b2tlbjogJ3JiJ307XG4gIGV4cG9ydCBjb25zdCBSQzogVG9rZW4gPSB7dG9rZW46ICdyYyd9O1xuICBleHBvcnQgY29uc3QgUlA6IFRva2VuID0ge3Rva2VuOiAncnAnfTtcbiAgZXhwb3J0IGNvbnN0IEVPTDogVG9rZW4gPSB7dG9rZW46ICdlb2wnfTtcbiAgZXhwb3J0IGNvbnN0IEVPRjogVG9rZW4gPSB7dG9rZW46ICdlb2YnfTtcbiAgLy8gSW1wb3J0YW50IG1hY3JvIGV4cGFuc2lvbiB0b2tlbnNcbiAgZXhwb3J0IGNvbnN0IERFRklORTogVG9rZW4gPSB7dG9rZW46ICdjcycsIHN0cjogJy5kZWZpbmUnfTtcbiAgZXhwb3J0IGNvbnN0IERPVF9FT0w6IFRva2VuID0ge3Rva2VuOiAnY3MnLCBzdHI6ICcuZW9sJ307XG4gIGV4cG9ydCBjb25zdCBFTFNFOiBUb2tlbiA9IHt0b2tlbjogJ2NzJywgc3RyOiAnLmVsc2UnfTtcbiAgZXhwb3J0IGNvbnN0IEVMU0VJRjogVG9rZW4gPSB7dG9rZW46ICdjcycsIHN0cjogJy5lbHNlaWYnfTtcbiAgZXhwb3J0IGNvbnN0IEVORElGOiBUb2tlbiA9IHt0b2tlbjogJ2NzJywgc3RyOiAnLmVuZGlmJ307XG4gIGV4cG9ydCBjb25zdCBFTkRNQUM6IFRva2VuID0ge3Rva2VuOiAnY3MnLCBzdHI6ICcuZW5kbWFjJ307XG4gIGV4cG9ydCBjb25zdCBFTkRNQUNSTzogVG9rZW4gPSB7dG9rZW46ICdjcycsIHN0cjogJy5lbmRtYWNybyd9O1xuICBleHBvcnQgY29uc3QgRU5EUkVQOiBUb2tlbiA9IHt0b2tlbjogJ2NzJywgc3RyOiAnLmVuZHJlcCd9O1xuICBleHBvcnQgY29uc3QgRU5EUkVQRUFUOiBUb2tlbiA9IHt0b2tlbjogJ2NzJywgc3RyOiAnLmVuZHJlcGVhdCd9O1xuICBleHBvcnQgY29uc3QgRU5EUFJPQzogVG9rZW4gPSB7dG9rZW46ICdjcycsIHN0cjogJy5lbmRwcm9jJ307XG4gIGV4cG9ydCBjb25zdCBFTkRTQ09QRTogVG9rZW4gPSB7dG9rZW46ICdjcycsIHN0cjogJy5lbmRzY29wZSd9O1xuICBleHBvcnQgY29uc3QgTE9DQUw6IFRva2VuID0ge3Rva2VuOiAnY3MnLCBzdHI6ICcubG9jYWwnfTtcbiAgZXhwb3J0IGNvbnN0IE1BQ1JPOiBUb2tlbiA9IHt0b2tlbjogJ2NzJywgc3RyOiAnLm1hY3JvJ307XG4gIGV4cG9ydCBjb25zdCBSRVBFQVQ6IFRva2VuID0ge3Rva2VuOiAnY3MnLCBzdHI6ICcucmVwZWF0J307XG4gIGV4cG9ydCBjb25zdCBTRVQ6IFRva2VuID0ge3Rva2VuOiAnY3MnLCBzdHI6ICcuc2V0J307XG4gIGV4cG9ydCBjb25zdCBTS0lQOiBUb2tlbiA9IHt0b2tlbjogJ2NzJywgc3RyOiAnLnNraXAnfTtcblxuICAvLyBUb2tlbnMgd2UgbWF0Y2hcbiAgZXhwb3J0IGNvbnN0IEJZVEU6IFRva2VuID0ge3Rva2VuOiAnY3MnLCBzdHI6ICcuYnl0ZSd9O1xuICBleHBvcnQgY29uc3QgV09SRDogVG9rZW4gPSB7dG9rZW46ICdjcycsIHN0cjogJy53b3JkJ307XG5cbiAgLy8gSW1wb3J0YW50IG9wZXJhdG9yIHRva2Vuc1xuICBleHBvcnQgY29uc3QgQ09MT046IFRva2VuID0ge3Rva2VuOiAnb3AnLCBzdHI6ICc6J307XG4gIC8vZXhwb3J0IGNvbnN0IERDT0xPTjogVG9rZW4gPSB7dG9rZW46ICdvcCcsIHN0cjogJzo6J307XG4gIGV4cG9ydCBjb25zdCBDT01NQTogVG9rZW4gPSB7dG9rZW46ICdvcCcsIHN0cjogJywnfTtcbiAgZXhwb3J0IGNvbnN0IFNUQVI6IFRva2VuID0ge3Rva2VuOiAnb3AnLCBzdHI6ICcqJ307XG4gIGV4cG9ydCBjb25zdCBJTU1FRElBVEU6IFRva2VuID0ge3Rva2VuOiAnb3AnLCBzdHI6ICcjJ307XG4gIGV4cG9ydCBjb25zdCBBU1NJR046IFRva2VuID0ge3Rva2VuOiAnb3AnLCBzdHI6ICc9J307XG5cbiAgZXhwb3J0IGZ1bmN0aW9uIG1hdGNoKGxlZnQ6IFRva2VuLCByaWdodDogVG9rZW4pOiBib29sZWFuIHtcbiAgICBpZiAobGVmdC50b2tlbiAhPT0gcmlnaHQudG9rZW4pIHJldHVybiBmYWxzZTtcbiAgICBpZiAobGVmdC50b2tlbiA9PT0gJ251bScgfHwgbGVmdC50b2tlbiA9PT0gJ3N0cicpIHJldHVybiB0cnVlO1xuICAgIGlmICgobGVmdCBhcyBTdHJpbmdUb2tlbikuc3RyICE9PSAocmlnaHQgYXMgU3RyaW5nVG9rZW4pLnN0cikgcmV0dXJuIGZhbHNlO1xuICAgIC8vIE5PVEU6IGRvbid0IGNvbXBhcmUgbnVtIGJlY2F1c2UgJ251bScgYWxyZWFkeSBlYXJseS1yZXR1cm5lZC5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGV4cG9ydCBmdW5jdGlvbiBlcShsZWZ0OiBUb2tlbnx1bmRlZmluZWQsIHJpZ2h0OiBUb2tlbnx1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgICBpZiAoIWxlZnQgfHwgIXJpZ2h0KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGxlZnQudG9rZW4gIT09IHJpZ2h0LnRva2VuKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGxlZnQudG9rZW4gPT09ICdncnAnKSByZXR1cm4gZmFsc2U7IC8vIGRvbid0IGNoZWNrIGdyb3Vwcy5cbiAgICBpZiAoKGxlZnQgYXMgU3RyaW5nVG9rZW4pLnN0ciAhPT0gKHJpZ2h0IGFzIFN0cmluZ1Rva2VuKS5zdHIpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoKGxlZnQgYXMgTnVtYmVyVG9rZW4pLm51bSAhPT0gKHJpZ2h0IGFzIE51bWJlclRva2VuKS5udW0pIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGV4cG9ydCBmdW5jdGlvbiBuYW1lKGFyZzogVG9rZW4pOiBzdHJpbmcge1xuICAgIHN3aXRjaCAoYXJnLnRva2VuKSB7XG4gICAgICBjYXNlICdudW0nOiByZXR1cm4gYE5VTVskJHthcmcubnVtLnRvU3RyaW5nKDE2KX1dYDtcbiAgICAgIGNhc2UgJ3N0cic6IHJldHVybiBgU1RSWyQke2FyZy5zdHJ9XWA7XG4gICAgICBjYXNlICdsYic6IHJldHVybiBgW2A7XG4gICAgICBjYXNlICdyYic6IHJldHVybiBgXWA7XG4gICAgICBjYXNlICdncnAnOiByZXR1cm4gYHtgO1xuICAgICAgY2FzZSAnbGMnOiByZXR1cm4gYHtgO1xuICAgICAgY2FzZSAncmMnOiByZXR1cm4gYH1gO1xuICAgICAgY2FzZSAnbHAnOiByZXR1cm4gYChgO1xuICAgICAgY2FzZSAncnAnOiByZXR1cm4gYClgO1xuICAgICAgY2FzZSAnZW9sJzogcmV0dXJuIGBFT0xgO1xuICAgICAgY2FzZSAnZW9mJzogcmV0dXJuIGBFT0ZgO1xuICAgICAgY2FzZSAnaWRlbnQnOlxuICAgICAgICByZXR1cm4gYXJnLnN0cjtcbiAgICAgIGNhc2UgJ2NzJzpcbiAgICAgIGNhc2UgJ29wJzpcbiAgICAgICAgcmV0dXJuIGAke2FyZy5zdHIudG9VcHBlckNhc2UoKX1gO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYXNzZXJ0TmV2ZXIoYXJnKTtcbiAgICB9XG4gIH1cblxuICBleHBvcnQgZnVuY3Rpb24gYXQoYXJnOiB7c291cmNlPzogU291cmNlSW5mb30pOiBzdHJpbmcge1xuICAgIGNvbnN0IHMgPSBhcmcuc291cmNlO1xuICAgIGlmICghcykgcmV0dXJuICcnO1xuICAgIGNvbnN0IHBhcmVudCA9IHMucGFyZW50ID8gYXQoe3NvdXJjZTogcy5wYXJlbnR9KSA6ICcnO1xuICAgIHJldHVybiBgXFxuICBhdCAke3MuZmlsZX06JHtzLmxpbmV9OiR7cy5jb2x1bW59JHtwYXJlbnR9YDtcbiAgICAvLyBUT0RPIC0gZGVmaW5pdGlvbiB2cyB1c2FnZT9cbiAgfVxuXG4gIGV4cG9ydCBmdW5jdGlvbiBuYW1lQXQoYXJnOiBUb2tlbik6IHN0cmluZyB7XG4gICAgcmV0dXJuIG5hbWUoYXJnKSArIGF0KGFyZyk7XG4gIH1cblxuICBleHBvcnQgZnVuY3Rpb24gZXhwZWN0RW9sKHRva2VuOiBUb2tlbnx1bmRlZmluZWQsIG5hbWUgPSAnZW5kIG9mIGxpbmUnKSB7XG4gICAgaWYgKHRva2VuKSB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkICR7bmFtZX06ICR7VG9rZW4ubmFtZUF0KHRva2VuKX1gKTtcbiAgfVxuXG4gIGV4cG9ydCBmdW5jdGlvbiBleHBlY3Qod2FudDogVG9rZW4sIHRva2VuOiBUb2tlbiwgcHJldj86IFRva2VuKSB7XG4gICAgaWYgKCF0b2tlbikge1xuICAgICAgaWYgKCFwcmV2KSB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkICR7bmFtZSh3YW50KX1gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgJHtuYW1lKHdhbnQpfSBhZnRlciAke25hbWVBdCh0b2tlbil9YCk7XG4gICAgfVxuICAgIGlmICghZXEod2FudCwgdG9rZW4pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkICR7bmFtZSh3YW50KX06ICR7bmFtZUF0KHRva2VuKX1gKTtcbiAgICB9XG4gIH1cblxuICBleHBvcnQgZnVuY3Rpb24gZXhwZWN0SWRlbnRpZmllcih0b2tlbjogVG9rZW58dW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2PzogVG9rZW4pOiBzdHJpbmcge1xuICAgIHJldHVybiBleHBlY3RTdHJpbmdUb2tlbignaWRlbnQnLCAnaWRlbnRpZmllcicsIHRva2VuLCBwcmV2KTtcbiAgfVxuXG4gIGV4cG9ydCBmdW5jdGlvbiBleHBlY3RTdHJpbmcodG9rZW46IFRva2VufHVuZGVmaW5lZCwgcHJldj86IFRva2VuKTogc3RyaW5nIHtcbiAgICByZXR1cm4gZXhwZWN0U3RyaW5nVG9rZW4oJ3N0cicsICdjb25zdGFudCBzdHJpbmcnLCB0b2tlbiwgcHJldik7XG4gIH1cblxuICBmdW5jdGlvbiBleHBlY3RTdHJpbmdUb2tlbih3YW50OiBTdHJpbmdUb2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW46IFRva2VufHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldj86IFRva2VuKTogc3RyaW5nIHtcbiAgICBpZiAoIXRva2VuKSB7XG4gICAgICBpZiAoIXByZXYpIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgJHtuYW1lfWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCAke25hbWV9IGFmdGVyICR7bmFtZUF0KHByZXYpfWApO1xuICAgIH1cbiAgICBpZiAodG9rZW4udG9rZW4gIT09IHdhbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgJHtuYW1lfTogJHtuYW1lQXQodG9rZW4pfWApO1xuICAgIH1cbiAgICByZXR1cm4gdG9rZW4uc3RyO1xuICB9XG4gICAgXG4gIC8vIGV4cG9ydCBmdW5jdGlvbiBmYWlsKHRva2VuOiBUb2tlbiwgbXNnOiBzdHJpbmcpOiBuZXZlciB7XG4gIC8vICAgaWYgXG4gIC8vICAgdGhyb3cgbmV3IEVycm9yKG1zZyArIFxuXG4gIC8vIH1cblxuICAvKipcbiAgICogR2l2ZW4gYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBpZGVudGlmaWVycywgcmV0dXJuIHRoZVxuICAgKiBpZGVudGlmaWVycyBhcyBhIGxpc3Qgb2Ygc3RyaW5ncy4gIFRocm93cyBhbiBlcnJvciBpZlxuICAgKiB0aGUgaW5wdXQgaXMgbm90IGFjdHVhbGx5IGEgY29tbWEtc2VwYXJhdGVkIGxpc3QuXG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gaWRlbnRzRnJvbUNMaXN0KGxpc3Q6IFRva2VuW10pOiBzdHJpbmdbXSB7XG4gICAgaWYgKCFsaXN0Lmxlbmd0aCkgcmV0dXJuIFtdO1xuICAgIGNvbnN0IG91dDogc3RyaW5nW10gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBsaXN0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBjb25zdCBpZGVudCA9IGxpc3RbaV07XG4gICAgICBpZiAoaWRlbnQ/LnRva2VuICE9PSAnaWRlbnQnKSB7XG4gICAgICAgIGlmIChpZGVudCkgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBpZGVudGlmaWVyOiAke25hbWVBdChpZGVudCl9YCk7XG4gICAgICAgIGNvbnN0IGxhc3QgPSBsaXN0W2xpc3QubGVuZ3RoIC0gMV07XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgaWRlbnRpZmllciBhZnRlciAke25hbWVBdChsYXN0KX1gKTtcbiAgICAgIH0gZWxzZSBpZiAoaSArIDEgPCBsaXN0Lmxlbmd0aCAmJiAhZXEobGlzdFtpICsgMV0sIENPTU1BKSkge1xuICAgICAgICBjb25zdCBzZXAgPSBsaXN0W2kgKyAxXTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBjb21tYTogJHtuYW1lQXQoc2VwKX1gKTtcbiAgICAgIH1cbiAgICAgIG91dC5wdXNoKGlkZW50LnN0cik7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH1cblxuICAvKiogRmluZHMgYSBiYWxhbmNlZCBwYXJlbi9icmFja2V0OiByZXR1cm5zIGl0cyBpbmRleCwgb3IgLTEuICovXG4gIGV4cG9ydCBmdW5jdGlvbiBmaW5kQmFsYW5jZWQodG9rZW5zOiBUb2tlbltdLCBpOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGNvbnN0IG9wZW4gPSB0b2tlbnNbaSsrXS50b2tlbjtcbiAgICBpZiAob3BlbiAhPT0gJ2xwJyAmJiBvcGVuICE9PSAnbGInKSB0aHJvdyBuZXcgRXJyb3IoYG5vbi1ncm91cGluZyB0b2tlbmApO1xuICAgIGNvbnN0IGNsb3NlID0gb3BlbiA9PT0gJ2xwJyA/ICdycCcgOiAncmInO1xuICAgIGxldCBkZXB0aCA9IDE7XG4gICAgZm9yICg7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHRvayA9IHRva2Vuc1tpXS50b2tlbjtcbiAgICAgIGRlcHRoICs9IE51bWJlcih0b2sgPT09IG9wZW4pIC0gTnVtYmVyKHRvayA9PT0gY2xvc2UpO1xuICAgICAgaWYgKCFkZXB0aCkgcmV0dXJuIGk7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdHMgb24gY29tbWFzIG5vdCBlbmNsb3NlZCBpbiBiYWxhbmNlZCBwYXJlbnMuICBCcmFjZXMgYXJlXG4gICAqIGlnbm9yZWQvbm90IGFsbG93ZWQgYXQgdGhpcyBwb2ludC4gIFRoaXMgaXMgaW50ZW5kZWQgZm9yIGFyaXRobWV0aWMuXG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcGFyc2VBcmdMaXN0KHRva2VuczogVG9rZW5bXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IDAsIGVuZCA9IHRva2Vucy5sZW5ndGgpOiBUb2tlbltdW10ge1xuICAgIGxldCBhcmc6IFRva2VuW10gPSBbXTtcbiAgICBjb25zdCBhcmdzID0gW2FyZ107XG4gICAgbGV0IHBhcmVucyA9IDA7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIGNvbnN0IHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgaWYgKCFwYXJlbnMgJiYgZXEodG9rZW4sIENPTU1BKSkge1xuICAgICAgICBhcmdzLnB1c2goYXJnID0gW10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJnLnB1c2godG9rZW4pO1xuICAgICAgICBpZiAoZXEodG9rZW4sIExQKSkgcGFyZW5zKys7XG4gICAgICAgIGlmIChlcSh0b2tlbiwgUlApKSB7XG4gICAgICAgICAgaWYgKC0tcGFyZW5zIDwgMCkgdGhyb3cgbmV3IEVycm9yKGBVbmJhbGFuY2VkIHBhcmVuJHthdCh0b2tlbil9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFyZ3M7XG4gIH1cblxuICBleHBvcnQgZnVuY3Rpb24gcGFyc2VBdHRyTGlzdCh0b2tlbnM6IFRva2VuW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBudW1iZXIpOiBNYXA8c3RyaW5nLCBUb2tlbltdPiB7XG4gICAgLy8gRXhwZWN0IGEgY29sb24uLi5cbiAgICAvLyBUT0RPIC0gYWxsb3cgY29sb24gaW5zaWRlIGJhbGFuY2VkIHBhcmVucz8gYWxsb3cgYSBzaW5nbGUgZ3JvdXA/XG4gICAgLy8gICAuc2VnbWVudCBcImZvb1wiIDpiYXIge2ZvbzpiYXJ9IDpiYXpcbiAgICBjb25zdCBvdXQgPSBuZXcgTWFwPHN0cmluZywgVG9rZW5bXT4oKTtcbiAgICBsZXQga2V5OiBzdHJpbmd8dW5kZWZpbmVkO1xuICAgIGxldCB2YWw6IFRva2VuW10gPSBbXTtcbiAgICBpZiAoc3RhcnQgPj0gdG9rZW5zLmxlbmd0aCkgcmV0dXJuIG91dDtcbiAgICBpZiAoIWVxKHRva2Vuc1tzdGFydF0sIENPTE9OKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkOiAke25hbWVBdCh0b2tlbnNbc3RhcnRdKX1gKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0ICsgMTsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdG9rID0gdG9rZW5zW2ldO1xuICAgICAgaWYgKGVxKHRvaywgQ09MT04pKSB7XG4gICAgICAgIGlmIChrZXkgPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIGtleSR7YXQodG9rKX1gKTtcbiAgICAgICAgb3V0LnNldChrZXksIHZhbCk7XG4gICAgICAgIGtleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFsID0gW107XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PSBudWxsKSB7XG4gICAgICAgIGtleSA9IGV4cGVjdElkZW50aWZpZXIodG9rKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbC5wdXNoKHRvayk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChrZXkgIT0gbnVsbCkge1xuICAgICAgb3V0LnNldChrZXksIHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cGVjdElkZW50aWZpZXIodW5kZWZpbmVkLCB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG4gIC8qKiBGaW5kcyBhIGNvbW1hIG9yIEVPTC4gKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIGZpbmRDb21tYSh0b2tlbnM6IFRva2VuW10sIHN0YXJ0OiBudW1iZXIpOiBudW1iZXIge1xuICAgIGNvbnN0IGluZGV4ID0gZmluZCh0b2tlbnMsIENPTU1BLCBzdGFydCk7XG4gICAgcmV0dXJuIGluZGV4IDwgMCA/IHRva2Vucy5sZW5ndGggOiBpbmRleDtcbiAgfVxuXG4gIC8qKiBGaW5kcyBhIHRva2VuLCBvciAtMSBpZiBub3QgZm91bmQuICovXG4gIGV4cG9ydCBmdW5jdGlvbiBmaW5kKHRva2VuczogVG9rZW5bXSwgd2FudDogVG9rZW4sIHN0YXJ0OiBudW1iZXIpOiBudW1iZXIge1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGVxKHRva2Vuc1tpXSwgd2FudCkpIHJldHVybiBpO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBleHBvcnQgZnVuY3Rpb24gY291bnQodHM6IFRva2VuW10pOiBudW1iZXIge1xuICAgIGxldCB0b3RhbCA9IDA7XG4gICAgZm9yIChjb25zdCB0IG9mIHRzKSB7XG4gICAgICBpZiAodC50b2tlbiA9PT0gJ2dycCcpIHtcbiAgICAgICAgdG90YWwgKz0gMiArIGNvdW50KHQuaW5uZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG90YWwrKztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvdGFsO1xuICB9XG5cbiAgZXhwb3J0IGZ1bmN0aW9uIGlzUmVnaXN0ZXIodDogVG9rZW4sIHJlZzogJ2EnfCd4J3wneScpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdC50b2tlbiA9PT0gJ2lkZW50JyAmJiB0LnN0ci50b0xvd2VyQ2FzZSgpID09PSByZWc7XG4gIH1cblxuICBleHBvcnQgZnVuY3Rpb24gc3RyKHQ6IFRva2VuKSB7XG4gICAgc3dpdGNoICh0LnRva2VuKSB7XG4gICAgICBjYXNlICdjcyc6XG4gICAgICBjYXNlICdpZGVudCc6XG4gICAgICBjYXNlICdzdHInOlxuICAgICAgY2FzZSAnb3AnOlxuICAgICAgICByZXR1cm4gdC5zdHI7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgTm9uLXN0cmluZyB0b2tlbjogJHtUb2tlbi5uYW1lQXQodCl9YCk7XG4gIH1cblxuICBleHBvcnQgZnVuY3Rpb24gc3RyaXAodDogVG9rZW4pOiBUb2tlbiB7XG4gICAgZGVsZXRlIHQuc291cmNlO1xuICAgIHJldHVybiB0O1xuICB9XG59XG5cbi8vIGludGVyZmFjZSBFeHByIHtcbi8vICAgLy8gb3BlcmF0b3IsIGZ1bmN0aW9uIG5hbWUsICcoKScsICd7fScsICdudW0nLCAnc3RyJywgJ2lkZW50J1xuLy8gICBvcDogc3RyaW5nO1xuLy8gICAvLyBvbmUgYXJnIGZvciBhIHVuYXJ5LCB0d28gZm9yIGJpbmFyeSwgb3IgTiBmb3IgY29tbWEgb3IgZnVuY3Rpb25cbi8vICAgYXJnczogRXhwcltdO1xuLy8gICAvLyBpZiBvcCA9PT0gJ251bSdcbi8vICAgbnVtOiBudW1iZXI7XG4vLyAgIC8vIGlmIG9wID09PSAnc3RyJyBvciAnaWRlbnQnXG4vLyAgIHN0cjogc3RyaW5nO1xuLy8gfVxuXG5leHBvcnQgY29uc3QgVE9LRU5GVU5DUyA9IG5ldyBTZXQoW1xuICAnLmJsYW5rJyxcbiAgJy5jb25zdCcsXG4gICcuZGVmaW5lZCcsIC8vIC5kZWYgP1xuICAnLmxlZnQnLFxuICAnLm1hdGNoJyxcbiAgJy5taWQnLFxuICAnLnJpZ2h0JyxcbiAgJy50Y291bnQnLFxuICAnLnhtYXRjaCcsXG5dKTtcblxuZXhwb3J0IGNvbnN0IERJUkVDVElWRVMgPSBbXG4gICcuZGVmaW5lJyxcbiAgJy5lbHNlJyxcbiAgJy5lbHNlaWYnLFxuICAnLmVuZGlmJyxcbiAgJy5lbmRtYWNybycsXG4gICcuZW5kcHJvYycsXG4gICcuZW5kc2NvcGUnLFxuICAnLmlkZW50JyxcbiAgJy5pZicsXG4gICcuaWZibGFuaycsXG4gICcuaWZkZWYnLFxuICAnLmlmbmJsYW5rJyxcbiAgJy5pZm5kZWYnLFxuICAnLmlmbnJlZicsXG4gICcuaWZyZWYnLFxuICAnLmluY2x1ZGUnLFxuICAnLmxvY2FsJyxcbiAgJy5tYWNybycsXG4gICcucHJvYycsXG4gICcuc2NvcGUnLFxuICAnLnNraXAnLFxuXSBhcyBjb25zdDtcbiJdfQ==