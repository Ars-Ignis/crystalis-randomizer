import { Token } from './token.js';
const DEBUG = false;
export class Define {
    constructor(overloads) {
        this.overloads = overloads;
    }
    canOverload() {
        return this.overloads[this.overloads.length - 1].canOverload();
    }
    append(define) {
        if (!this.canOverload()) {
            const prevDef = this.overloads[this.overloads.length - 1].definition;
            const at = prevDef ? Token.at(prevDef) : '';
            const prev = at.replace(/at/, 'previously defined at');
            const nextDef = define.overloads[0].definition;
            const next = nextDef ? Token.nameAt(nextDef) : '';
            throw new Error(`Non-overloadable: ${next}${prev}`);
        }
        this.overloads.push(...define.overloads);
    }
    expand(tokens, start) {
        const reasons = [];
        for (const overload of this.overloads) {
            const result = overload.expand(tokens, start);
            if (Array.isArray(result))
                return result;
            reasons.push(result);
        }
        if (DEBUG)
            console.error(reasons.join('\n'));
        return undefined;
    }
    static from(macro) {
        var _a;
        if (!Token.eq(macro[0], Token.DEFINE))
            throw new Error(`invalid`);
        if (((_a = macro[1]) === null || _a === void 0 ? void 0 : _a.token) !== 'ident')
            throw new Error(`invalid`);
        const paramStart = macro[2];
        let overload;
        if (!paramStart) {
            overload = new TexStyleDefine([], [], macro[1]);
        }
        else if (paramStart.token === 'grp') {
            overload = new TexStyleDefine(paramStart.inner, macro.slice(3), macro[1]);
        }
        else if (paramStart.token === 'lp') {
            const paramEnd = Token.findBalanced(macro, 2);
            if (paramEnd < 0) {
                throw new Error(`Expected close paren ${Token.nameAt(macro[2])}`);
            }
            overload =
                new CStyleDefine(Token.identsFromCList(macro.slice(3, paramEnd)), macro.slice(paramEnd + 1), macro[1]);
        }
        else {
            overload = new TexStyleDefine([], macro.slice(2), macro[1]);
        }
        return new Define([overload]);
    }
}
function produce(tokens, start, end, replacements, production) {
    const splice = [];
    let overflow = [];
    let line = splice;
    for (const tok of production) {
        if (tok.token === 'ident') {
            const param = replacements.get(tok.str);
            if (param) {
                line.push(...param);
                continue;
            }
        }
        else if (Token.eq(tok, Token.DOT_EOL)) {
            overflow.push(line = []);
            continue;
        }
        line.push(tok);
    }
    overflow = overflow.filter(l => l.length);
    if (overflow.length && end < tokens.length) {
        return 'cannot expand .eol without consuming to end of line';
    }
    tokens.splice(start, end - start, ...splice);
    return overflow;
}
class CStyleDefine {
    constructor(params, production, definition) {
        this.params = params;
        this.production = production;
        this.definition = definition;
    }
    expand(tokens, start) {
        let i = start + 1;
        let splice = this.params.length ? tokens.length : start;
        let end = splice;
        const replacements = new Map();
        if (start < tokens.length && Token.eq(Token.LP, tokens[i])) {
            end = Token.findBalanced(tokens, i);
            if (end < 0) {
                return 'missing close paren for enclosed C-style expansion';
            }
            splice = end + 1;
            i++;
        }
        const args = Token.parseArgList(tokens, i, end);
        if (args.length > this.params.length) {
            return 'too many args';
        }
        for (i = 0; i < this.params.length; i++) {
            let arg = args[i] || [];
            const front = arg[0];
            if (arg.length === 1 && front.token === 'grp') {
                arg = front.inner;
            }
            replacements.set(this.params[i], arg);
        }
        return produce(tokens, start, splice, replacements, this.production);
    }
    canOverload() { return Boolean(this.params.length); }
}
class TexStyleDefine {
    constructor(pattern, production, definition) {
        this.pattern = pattern;
        this.production = production;
        this.definition = definition;
    }
    expand(tokens, start) {
        var _a;
        let i = start + 1;
        const replacements = new Map();
        for (let patPos = 0; patPos < this.pattern.length; patPos++) {
            const pat = this.pattern[patPos];
            if (pat.token === 'ident') {
                const delim = this.pattern[patPos + 1];
                if (!delim || ((_a = delim) === null || _a === void 0 ? void 0 : _a.token) === 'ident') {
                    const tok = tokens[i++];
                    if (!tok)
                        return `missing undelimited argument ${Token.name(pat)}`;
                    replacements.set(pat.str, tok.token === 'grp' ? tok.inner : [tok]);
                }
                else {
                    const end = Token.eq(delim, Token.DOT_EOL) ?
                        tokens.length : Token.find(tokens, delim, i);
                    if (end < 0)
                        return `could not find delimiter ${Token.name(delim)}`;
                    replacements.set(pat.str, tokens.slice(i, end));
                    i = end;
                }
            }
            else if (Token.eq(pat, Token.DOT_EOL)) {
                if (i < tokens.length)
                    return `could not match .eol`;
            }
            else {
                if (!Token.eq(tokens[i++], pat)) {
                    return `could not match: ${Token.name(pat)}`;
                }
            }
        }
        return produce(tokens, start, i, replacements, this.production);
    }
    canOverload() { return Boolean(this.pattern.length); }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVmaW5lLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2pzL2FzbS9kZWZpbmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFDLEtBQUssRUFBQyxNQUFNLFlBQVksQ0FBQztBQUVqQyxNQUFNLEtBQUssR0FBRyxLQUFLLENBQUM7QUFFcEIsTUFBTSxPQUFPLE1BQU07SUFDakIsWUFBcUMsU0FBMkI7UUFBM0IsY0FBUyxHQUFULFNBQVMsQ0FBa0I7SUFBRyxDQUFDO0lBU3BFLFdBQVc7UUFDVCxPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDakUsQ0FBQztJQUVELE1BQU0sQ0FBQyxNQUFjO1FBQ25CLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLEVBQUU7WUFDdkIsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUM7WUFDckUsTUFBTSxFQUFFLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7WUFDNUMsTUFBTSxJQUFJLEdBQUcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsdUJBQXVCLENBQUMsQ0FBQztZQUN2RCxNQUFNLE9BQU8sR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQztZQUMvQyxNQUFNLElBQUksR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztZQUNsRCxNQUFNLElBQUksS0FBSyxDQUFDLHFCQUFxQixJQUFJLEdBQUcs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RUFBRSxHQUFHLENBQUMsRUFBRTtvQkFDL0IsT0FBTyxvQkFBb0IsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDO2lCQUM5QzthQUNGO1NBQ0Y7UUFFRCxPQUFPLE9BQU8sQ0FBQyxNQUFNLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBRSxZQUFZLEVBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQ2xFLENBQUM7SUFFRCxXQUFXLEtBQUssT0FBTyxPQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7Q0FDdkQiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1Rva2VufSBmcm9tICcuL3Rva2VuLmpzJztcblxuY29uc3QgREVCVUcgPSBmYWxzZTtcblxuZXhwb3J0IGNsYXNzIERlZmluZSB7XG4gIHByaXZhdGUgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBvdmVybG9hZHM6IERlZmluZU92ZXJsb2FkW10pIHt9XG5cbiAgLy8gb3ZlcnJpZGUobWFjcm86IE1hY3JvRXhwYW5zaW9uKTogTWFjcm9FeHBhbnNpb24ge1xuICAvLyAgIGlmIChtYWNybyBpbnN0YW5jZW9mIERlZmluZSkge1xuICAvLyAgICAgcmV0dXJuIG5ldyBEZWZpbmUoWy4uLnRoaXMub3ZlcmxvYWRzLCAuLi5tYWNyby5vdmVybG9hZHNdKTtcbiAgLy8gICB9XG4gIC8vICAgcmV0dXJuIG1hY3JvO1xuICAvLyB9XG5cbiAgY2FuT3ZlcmxvYWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMub3ZlcmxvYWRzW3RoaXMub3ZlcmxvYWRzLmxlbmd0aCAtIDFdLmNhbk92ZXJsb2FkKCk7XG4gIH1cblxuICBhcHBlbmQoZGVmaW5lOiBEZWZpbmUpIHtcbiAgICBpZiAoIXRoaXMuY2FuT3ZlcmxvYWQoKSkge1xuICAgICAgY29uc3QgcHJldkRlZiA9IHRoaXMub3ZlcmxvYWRzW3RoaXMub3ZlcmxvYWRzLmxlbmd0aCAtIDFdLmRlZmluaXRpb247XG4gICAgICBjb25zdCBhdCA9IHByZXZEZWYgPyBUb2tlbi5hdChwcmV2RGVmKSA6ICcnO1xuICAgICAgY29uc3QgcHJldiA9IGF0LnJlcGxhY2UoL2F0LywgJ3ByZXZpb3VzbHkgZGVmaW5lZCBhdCcpO1xuICAgICAgY29uc3QgbmV4dERlZiA9IGRlZmluZS5vdmVybG9hZHNbMF0uZGVmaW5pdGlvbjtcbiAgICAgIGNvbnN0IG5leHQgPSBuZXh0RGVmID8gVG9rZW4ubmFtZUF0KG5leHREZWYpIDogJyc7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vbi1vdmVybG9hZGFibGU6ICR7bmV4dH0ke3ByZXZ9YCk7XG4gICAgfVxuICAgIHRoaXMub3ZlcmxvYWRzLnB1c2goLi4uZGVmaW5lLm92ZXJsb2Fkcyk7XG4gIH1cblxuICAvKipcbiAgICogRXhwYW5kcyBpbiBwbGFjZSwgcG9zc2libHkgaW4gdGhlIG1pZGRsZSBvZiBhIGxpbmUhICBSZXR1cm5zIHRydWVcbiAgICogaWYgc3VjY2Vzc2Z1bC4gIE90aGVyd2lzZSByZXR1cm4gZmFsc2UgYW5kIGRvIG5vdGhpbmcuXG4gICAqL1xuICBleHBhbmQodG9rZW5zOiBUb2tlbltdLCBzdGFydDogbnVtYmVyKTogVG9rZW5bXVtdfHVuZGVmaW5lZCB7XG4gICAgY29uc3QgcmVhc29ucyA9IFtdO1xuICAgIGZvciAoY29uc3Qgb3ZlcmxvYWQgb2YgdGhpcy5vdmVybG9hZHMpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IG92ZXJsb2FkLmV4cGFuZCh0b2tlbnMsIHN0YXJ0KTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gICAgICByZWFzb25zLnB1c2gocmVzdWx0KTtcbiAgICB9XG4gICAgaWYgKERFQlVHKSBjb25zb2xlLmVycm9yKHJlYXNvbnMuam9pbignXFxuJykpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyBOT1RFOiBtYWNyb1swXSBpcyAuZGVmaW5lXG4gIHN0YXRpYyBmcm9tKG1hY3JvOiBUb2tlbltdKSB7XG4gICAgaWYgKCFUb2tlbi5lcShtYWNyb1swXSwgVG9rZW4uREVGSU5FKSkgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkYCk7XG4gICAgaWYgKG1hY3JvWzFdPy50b2tlbiAhPT0gJ2lkZW50JykgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkYCk7XG4gICAgLy8gcGFyc2UgdGhlIHBhcmFtZXRlciBsaXN0LCBpZiBhbnlcbiAgICBjb25zdCBwYXJhbVN0YXJ0ID0gbWFjcm9bMl07XG4gICAgbGV0IG92ZXJsb2FkOiBEZWZpbmVPdmVybG9hZDtcbiAgICBpZiAoIXBhcmFtU3RhcnQpIHtcbiAgICAgIC8vIGJsYW5rIG1hY3JvXG4gICAgICBvdmVybG9hZCA9IG5ldyBUZXhTdHlsZURlZmluZShbXSwgW10sIG1hY3JvWzFdKTtcbiAgICB9IGVsc2UgaWYgKHBhcmFtU3RhcnQudG9rZW4gPT09ICdncnAnKSB7XG4gICAgICAvLyBUZVgtc3R5bGUgcGFyYW0gbGlzdFxuICAgICAgb3ZlcmxvYWQgPSBuZXcgVGV4U3R5bGVEZWZpbmUocGFyYW1TdGFydC5pbm5lciwgbWFjcm8uc2xpY2UoMyksIG1hY3JvWzFdKTtcbiAgICB9IGVsc2UgaWYgKHBhcmFtU3RhcnQudG9rZW4gPT09ICdscCcpIHtcbiAgICAgIC8vIEMtc3R5bGUgcGFyYW0gbGlzdFxuICAgICAgY29uc3QgcGFyYW1FbmQgPSBUb2tlbi5maW5kQmFsYW5jZWQobWFjcm8sIDIpO1xuICAgICAgaWYgKHBhcmFtRW5kIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGNsb3NlIHBhcmVuICR7VG9rZW4ubmFtZUF0KG1hY3JvWzJdKX1gKTtcbiAgICAgIH1cbiAgICAgIG92ZXJsb2FkID1cbiAgICAgICAgICBuZXcgQ1N0eWxlRGVmaW5lKFRva2VuLmlkZW50c0Zyb21DTGlzdChtYWNyby5zbGljZSgzLCBwYXJhbUVuZCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFjcm8uc2xpY2UocGFyYW1FbmQgKyAxKSwgbWFjcm9bMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBubyBwYXJhbSBsaXN0XG4gICAgICBvdmVybG9hZCA9IG5ldyBUZXhTdHlsZURlZmluZShbXSwgbWFjcm8uc2xpY2UoMiksIG1hY3JvWzFdKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEZWZpbmUoW292ZXJsb2FkXSk7XG4gIH1cbn1cblxuaW50ZXJmYWNlIERlZmluZU92ZXJsb2FkIHtcbiAgcmVhZG9ubHkgZGVmaW5pdGlvbj86IFRva2VuO1xuICBleHBhbmQodG9rZW5zOiBUb2tlbltdLCBzdGFydDogbnVtYmVyKTogc3RyaW5nfFRva2VuW11bXTtcbiAgY2FuT3ZlcmxvYWQoKTogYm9vbGVhbjtcbn1cblxuZnVuY3Rpb24gcHJvZHVjZSh0b2tlbnM6IFRva2VuW10sXG4gICAgICAgICAgICAgICAgIHN0YXJ0OiBudW1iZXIsXG4gICAgICAgICAgICAgICAgIGVuZDogbnVtYmVyLFxuICAgICAgICAgICAgICAgICByZXBsYWNlbWVudHM6IE1hcDxzdHJpbmcsIFRva2VuW10+LFxuICAgICAgICAgICAgICAgICBwcm9kdWN0aW9uOiBUb2tlbltdKTogc3RyaW5nfFRva2VuW11bXSB7XG4gIGNvbnN0IHNwbGljZTogVG9rZW5bXSA9IFtdO1xuICBsZXQgb3ZlcmZsb3c6IFRva2VuW11bXSA9IFtdO1xuICBsZXQgbGluZSA9IHNwbGljZTtcbiAgZm9yIChjb25zdCB0b2sgb2YgcHJvZHVjdGlvbikge1xuICAgIGlmICh0b2sudG9rZW4gPT09ICdpZGVudCcpIHtcbiAgICAgIGNvbnN0IHBhcmFtID0gcmVwbGFjZW1lbnRzLmdldCh0b2suc3RyKTtcbiAgICAgIGlmIChwYXJhbSkge1xuICAgICAgICAvLyB0aGlzIGlzIGFjdHVhbGx5IGEgcGFyYW1ldGVyXG4gICAgICAgIGxpbmUucHVzaCguLi5wYXJhbSk7IC8vIFRPRE8gLSBjb3B5IHcvIGNoaWxkIHNvdXJjZWluZm8/XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoVG9rZW4uZXEodG9rLCBUb2tlbi5ET1RfRU9MKSkge1xuICAgICAgb3ZlcmZsb3cucHVzaChsaW5lID0gW10pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGxpbmUucHVzaCh0b2spO1xuICB9XG4gIG92ZXJmbG93ID0gb3ZlcmZsb3cuZmlsdGVyKGwgPT4gbC5sZW5ndGgpO1xuICBpZiAob3ZlcmZsb3cubGVuZ3RoICYmIGVuZCA8IHRva2Vucy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJ2Nhbm5vdCBleHBhbmQgLmVvbCB3aXRob3V0IGNvbnN1bWluZyB0byBlbmQgb2YgbGluZSc7XG4gIH1cbiAgdG9rZW5zLnNwbGljZShzdGFydCwgZW5kIC0gc3RhcnQsIC4uLnNwbGljZSk7XG4gIHJldHVybiBvdmVyZmxvdztcbn1cblxuY2xhc3MgQ1N0eWxlRGVmaW5lIGltcGxlbWVudHMgRGVmaW5lT3ZlcmxvYWQge1xuICBjb25zdHJ1Y3RvcihyZWFkb25seSBwYXJhbXM6IHN0cmluZ1tdLFxuICAgICAgICAgICAgICByZWFkb25seSBwcm9kdWN0aW9uOiBUb2tlbltdLFxuICAgICAgICAgICAgICByZWFkb25seSBkZWZpbml0aW9uPzogVG9rZW4pIHt9XG5cbiAgZXhwYW5kKHRva2VuczogVG9rZW5bXSwgc3RhcnQ6IG51bWJlcik6IHN0cmluZ3xUb2tlbltdW10ge1xuICAgIGxldCBpID0gc3RhcnQgKyAxOyAvLyBza2lwIHBhc3QgdGhlIG1hY3JvIGNhbGwgaWRlbnRpZmllclxuICAgIGxldCBzcGxpY2UgPSB0aGlzLnBhcmFtcy5sZW5ndGggPyB0b2tlbnMubGVuZ3RoIDogc3RhcnQ7XG4gICAgbGV0IGVuZCA9IHNwbGljZTtcbiAgICBjb25zdCByZXBsYWNlbWVudHMgPSBuZXcgTWFwPHN0cmluZywgVG9rZW5bXT4oKTtcbiAgICBcbiAgICBpZiAoc3RhcnQgPCB0b2tlbnMubGVuZ3RoICYmIFRva2VuLmVxKFRva2VuLkxQLCB0b2tlbnNbaV0pKSB7XG4gICAgICBlbmQgPSBUb2tlbi5maW5kQmFsYW5jZWQodG9rZW5zLCBpKTtcbiAgICAgIGlmIChlbmQgPCAwKSB7XG4gICAgICAgIC8vIHRocm93P1xuICAgICAgICByZXR1cm4gJ21pc3NpbmcgY2xvc2UgcGFyZW4gZm9yIGVuY2xvc2VkIEMtc3R5bGUgZXhwYW5zaW9uJztcbiAgICAgIH1cbiAgICAgIHNwbGljZSA9IGVuZCArIDE7XG4gICAgICBpKys7XG4gICAgICAvL3RvayA9IG5ldyBTY2FubmVyKHRva2Vucy5zbGljZSgwLCBpKSwgc3RhcnQgKyAxKTtcbiAgICB9XG4gICAgLy8gRmluZCBhIGNvbW1hLCBza2lwcGluZyBiYWxhbmNlZCBwYXJlbnMuXG4gICAgY29uc3QgYXJncyA9IFRva2VuLnBhcnNlQXJnTGlzdCh0b2tlbnMsIGksIGVuZCk7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gdGhpcy5wYXJhbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gJ3RvbyBtYW55IGFyZ3MnO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGFyZyA9IGFyZ3NbaV0gfHwgW107XG4gICAgICBjb25zdCBmcm9udCA9IGFyZ1swXTtcbiAgICAgIGlmIChhcmcubGVuZ3RoID09PSAxICYmIGZyb250LnRva2VuID09PSAnZ3JwJykge1xuICAgICAgICBhcmcgPSBmcm9udC5pbm5lcjtcbiAgICAgIH1cbiAgICAgIHJlcGxhY2VtZW50cy5zZXQodGhpcy5wYXJhbXNbaV0sIGFyZyk7XG4gICAgfVxuICAgIC8vIEFsbCBwYXJhbXMgZmlsbGVkIGluLCBtYWtlIHJlcGxhY2VtZW50IGFuZCBmaWxsIGl0IGluLlxuICAgIHJldHVybiBwcm9kdWNlKHRva2Vucywgc3RhcnQsIHNwbGljZSwgcmVwbGFjZW1lbnRzLCB0aGlzLnByb2R1Y3Rpb24pO1xuICB9XG5cbiAgY2FuT3ZlcmxvYWQoKSB7IHJldHVybiBCb29sZWFuKHRoaXMucGFyYW1zLmxlbmd0aCk7IH1cbn1cblxuY2xhc3MgVGV4U3R5bGVEZWZpbmUgaW1wbGVtZW50cyBEZWZpbmVPdmVybG9hZCB7XG4gIGNvbnN0cnVjdG9yKHJlYWRvbmx5IHBhdHRlcm46IFRva2VuW10sXG4gICAgICAgICAgICAgIHJlYWRvbmx5IHByb2R1Y3Rpb246IFRva2VuW10sXG4gICAgICAgICAgICAgIHJlYWRvbmx5IGRlZmluaXRpb24/OiBUb2tlbikge31cbiAgZXhwYW5kKHRva2VuczogVG9rZW5bXSwgc3RhcnQ6IG51bWJlcik6IHN0cmluZ3xUb2tlbltdW10ge1xuICAgIGxldCBpID0gc3RhcnQgKyAxOyAvLyBza2lwIHBhc3QgdGhlIG1hY3JvIGNhbGwgaWRlbnRpZmllclxuICAgIGNvbnN0IHJlcGxhY2VtZW50cyA9IG5ldyBNYXA8c3RyaW5nLCBUb2tlbltdPigpO1xuICAgIGZvciAobGV0IHBhdFBvcyA9IDA7IHBhdFBvcyA8IHRoaXMucGF0dGVybi5sZW5ndGg7IHBhdFBvcysrKSB7XG4gICAgICBjb25zdCBwYXQgPSB0aGlzLnBhdHRlcm5bcGF0UG9zXTtcbiAgICAgIGlmIChwYXQudG9rZW4gPT09ICdpZGVudCcpIHtcbiAgICAgICAgY29uc3QgZGVsaW0gPSB0aGlzLnBhdHRlcm5bcGF0UG9zICsgMV07XG4gICAgICAgIGlmICghZGVsaW0gfHwgZGVsaW0/LnRva2VuID09PSAnaWRlbnQnKSB7XG4gICAgICAgICAgLy8gcGFyc2UgdW5kZWxpbWl0ZWRcbiAgICAgICAgICBjb25zdCB0b2sgPSB0b2tlbnNbaSsrXTtcbiAgICAgICAgICBpZiAoIXRvaykgcmV0dXJuIGBtaXNzaW5nIHVuZGVsaW1pdGVkIGFyZ3VtZW50ICR7VG9rZW4ubmFtZShwYXQpfWA7XG4gICAgICAgICAgcmVwbGFjZW1lbnRzLnNldChwYXQuc3RyLCB0b2sudG9rZW4gPT09ICdncnAnID8gdG9rLmlubmVyIDogW3Rva10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHBhcnNlIGRlbGltaXRlZFxuICAgICAgICAgIGNvbnN0IGVuZCA9IFRva2VuLmVxKGRlbGltLCBUb2tlbi5ET1RfRU9MKSA/XG4gICAgICAgICAgICAgIHRva2Vucy5sZW5ndGggOiBUb2tlbi5maW5kKHRva2VucywgZGVsaW0sIGkpO1xuICAgICAgICAgIGlmIChlbmQgPCAwKSByZXR1cm4gYGNvdWxkIG5vdCBmaW5kIGRlbGltaXRlciAke1Rva2VuLm5hbWUoZGVsaW0pfWA7XG4gICAgICAgICAgLy9wYXRQb3MrKztcbiAgICAgICAgICByZXBsYWNlbWVudHMuc2V0KHBhdC5zdHIsIHRva2Vucy5zbGljZShpLCBlbmQpKTtcbiAgICAgICAgICBpID0gZW5kO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKFRva2VuLmVxKHBhdCwgVG9rZW4uRE9UX0VPTCkpIHtcbiAgICAgICAgaWYgKGkgPCB0b2tlbnMubGVuZ3RoKSByZXR1cm4gYGNvdWxkIG5vdCBtYXRjaCAuZW9sYDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRva2VuIHRvIG1hdGNoXG4gICAgICAgIGlmICghVG9rZW4uZXEodG9rZW5zW2krK10sIHBhdCkpIHtcbiAgICAgICAgICByZXR1cm4gYGNvdWxkIG5vdCBtYXRjaDogJHtUb2tlbi5uYW1lKHBhdCl9YDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBOb3cgc3BsaWNlIGluIHRoZSBwcm9kdWN0aW9uIGFuZCBmaWxsIHRvIGVuZCBvZiBsaW5lIFxuICAgIHJldHVybiBwcm9kdWNlKHRva2Vucywgc3RhcnQsIGksIHJlcGxhY2VtZW50cywgdGhpcy5wcm9kdWN0aW9uKTtcbiAgfVxuXG4gIGNhbk92ZXJsb2FkKCkgeyByZXR1cm4gQm9vbGVhbih0aGlzLnBhdHRlcm4ubGVuZ3RoKTsgfVxufVxuXG5cbi8vIGNhNjUgYmVoYXZpb3Jcbi8vICAtIGV4cGFuZCBtYWNyb3MgaW4gYXJndW1lbnRzIGJlZm9yZSBzZW5kaW5nIHRoZW0gaW50byBvdXRlciBtYWNyb1xuLy8gIC0gZG9uJ3QgZXhwYW5kIG1hY3JvcyBpbiBwcm9kdWN0aW9uXG4vLyAgLSBuZXN0ZWQgYnJhY2VzIGdvIGF3YXkgYmVjYXVzZSBleHBhbnNpb24gaGFwcGVucyB3aGlsZSBsb29raW5nIGZvciBjbG9zaW5nIGJyYWNlXG4vLyAgLSB3aGVuIHNjYW5uaW5nIGZvciBhcmd1bWVudHMsIGNvbW1hIHRlcm1pbmF0ZXMsIHNvXG4vLyAgICAgQUEoYTEsIGEyKSAtPiBhMSwgYTIsIGExLCBhMlxuLy8gICAgIEFBIDEsIDIsIDMgLS0tPiAxLCAyLCAxLCAyLCAzXG4vLyAgICBidXRcbi8vICAgICBBQSB7MSwgMn0sIDMgIGRvZXNuJ3Qgc2VlbSB0byBleHBhbmQgdG8gIDEsIDIsIDMsIDEsIDIsIDMgID8/P1xuLy8gIC0gc3BhY2UgYmVmb3JlIHBhcmVuIGluIGRlZm4gZG9lc24ndCBjaGFuZ2UgYW55dGhpbmdcblxuXG4vLyBmdW5jdGlvbiBmYWlsKHQ6IFRva2VuLCBtc2c6IHN0cmluZyk6IG5ldmVyIHtcbi8vICAgbGV0IHMgPSB0LnNvdXJjZTtcbi8vICAgaWYgKHMpIG1zZyArPSBgXFxuICBhdCAke3MuZmlsZX06JHtzLmxpbmV9OiR7cy5jb2x1bW59OiAke3MuY29udGVudH1gO1xuLy8gICB3aGlsZSAocz8ucGFyZW50KSB7XG4vLyAgICAgcyA9IHMucGFyZW50O1xuLy8gICAgIG1zZyArPSBgXFxuICBpbmNsdWRlZCBmcm9tICR7cy5maWxlfToke3MubGluZX06JHtzLmNvbHVtbn06ICR7cy5jb250ZW50fWA7XG4vLyAgIH1cbi8vICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4vLyB9XG4iXX0=